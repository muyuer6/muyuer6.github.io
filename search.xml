<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenCV之图像显示</title>
      <link href="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>记录OpenCV入门经历以及数字图像处理课程的实验</p><span id="more"></span><h1 id="OpenCV学习记录（一）"><a href="#OpenCV学习记录（一）" class="headerlink" title="OpenCV学习记录（一）"></a>OpenCV学习记录（一）</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>使用Python搭配VS-Code和OpenCV库进行实验环境的配置。</p><p>由于python环境和VS-Code很早就安装配置好了，此部分只谈如何在前两者的基础上配置OpenCV的实验环境。</p><p>相比于C++&amp;VS-Code&amp;OpenCV 环境的配置，我要做的其实很简单。</p><p>在命令行窗口（cmd）中输入<code>pip install opencv-python</code>，环境就配置完成了。</p><p>然后在新建一个文件夹作为项目地址，用VSCode将其打开，然后新建一个文件，如<code>ex.py</code>，写入代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">&#x27;eg.jpg&#x27;</span>,cv2.IMREAD_UNCHANGED)</span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;girl&#x27;</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;girl&#x27;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>eg.jpg</code>是py文件同级文件夹下的一张图片，如果图片位置在其他地方，则可以通过相对路径或者绝对路径来访问。</p><p>然后运行即可，运行效果如下：</p><img src="/../数字图像处理/一、OpenCV之图像显示/image-20221027204812288.png" alt="image-20221027204812288" style="zoom:50%;"><p> 绝对路径较为简单，但若路径较长会使观感不太好。若使用相对路径，可能还需要简单的配置。</p><h2 id="VS-Code设置"><a href="#VS-Code设置" class="headerlink" title="VS-Code设置"></a>VS-Code设置</h2><p>说到相对路径，VS-Code有一个较为奇怪的设置。</p><p>即运行<code>print(os.getcwd())</code>这行代码时，程序在VS-Code中运行的输出和直接运行后在cmd中的输出结果不一致。如，若该文件的实际位置是<code>D:\Course\DigImgProcessing\exp1\exp.py</code>，则前者输出是<code>D:\Course\DigImgProcessing</code>，后者输出是<code>D:\Course\DigImgProcessing\exp1</code>。</p><p>原因：VS Code把用“File”菜单-&gt;”Open Folder…”选项打开的文件夹的位置(${workspaceFolder} )当做<strong>默认当前工作路径</strong>。</p><p><strong>解决方案：</strong></p><p>先在Settings中，<strong>勾选“Terminal：Excute In File Dir”</strong>，</p><p>然后在项目配置文件<code>launch.json</code>中添加<code>&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</code>即可。</p><h2 id="从实验讲起"><a href="#从实验讲起" class="headerlink" title="从实验讲起"></a>从实验讲起</h2><p>终于谈到了学习OpenCV的原因，其实就是数字图像处理实验需要我学习和使用它。</p><p>我是怎么摸索并知道要用它来做实验？其实很简单，无非是老一套的搜索原题找到教程罢了，这一点就不再赘述，先看看第一次实验的题目吧！</p><blockquote><p>Pset1_Basic Image Manipulation</p><p>实验1-1：图像显示</p><p>实验要求：</p><p>1）利用图像库的功能，实现从文件加载图像，并在窗口中进行显示的功能；</p><p>2）利用常见的图像文件格式（.jpg； .png； .bmp； .gif）进行测试。</p><p><img src="/../%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/clip_image002.jpg" alt="img"></p><p>实验1-2：图像合成</p><p>实验要求：</p><p>1）现有一张4通道透明图像a.png:</p><p>2）从其中提取出alpha通道并显示;</p><p>3）用alpha混合，为a.png替换一张新的背景（bg.png）。 </p><p><img src="/../%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/image-20221027221157348.png" alt="image-20221027221157348"></p></blockquote><h3 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1-1"></a>实验1-1</h3><p>首先是实现从文件加载图像。</p><p>对于像以<code>jpg</code>, <code>png</code>, <code>bmp</code> 甚至<code>webp</code>为文件格式（后缀）的静态图片来说，打开并加载的方式又很多种，因为除了OpenCV以外，python还有很多图像处理的库。</p><p>对于此实验，可以使用 opencv或者python的PIL库（pillow）来实现。</p><h4 id="打开静态图片"><a href="#打开静态图片" class="headerlink" title="打开静态图片"></a>打开静态图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">path=<span class="string">&#x27;./1-1/eg.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#opencv</span></span><br><span class="line">img=cv2.imread(path,cv2.IMREAD_UNCHANGED)</span><br><span class="line"><span class="comment">#nameWindow()的作用是为图片准备一个窗口，使得图片是可交互的（如改变大小，这与第二个参数有关），前提是nameWindow和imshow的命名一致。</span></span><br><span class="line"><span class="comment">#直接使用imshow而不用nameWindow也行</span></span><br><span class="line">cv2.nameWindow(<span class="string">&#x27;girl&#x27;</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;girl&#x27;</span>,img)</span><br><span class="line"><span class="comment">#waitKey中参数决定了窗口打开时长，当参数为0时表示需要手动操作，不会自动关闭。</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#PIL</span></span><br><span class="line">img=Image.<span class="built_in">open</span>(path)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><h4 id="打开GIF图"><a href="#打开GIF图" class="headerlink" title="打开GIF图"></a>打开GIF图</h4><p>由于没有基础，做这个就颇费了一番功夫，好在也不算太复杂。</p><p>对此，我也找到了两种实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#识别图像模式</span></span><br><span class="line">im=Image.<span class="built_in">open</span>(file)</span><br><span class="line"><span class="comment">#gif图的mode为P，其他图像一般为RGB或者RGBA</span></span><br><span class="line"><span class="built_in">print</span>(im.mode)</span><br><span class="line"><span class="comment">#或者根据文件的格式来选择读入时使用的方法</span></span><br><span class="line"><span class="built_in">print</span>(im.<span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用PIL库来处理GIF</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showGif1</span>(<span class="params">im</span>):</span><br><span class="line">    <span class="comment">#使用迭代器</span></span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):    </span><br><span class="line">        frame = frame.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        cv2_frame = np.array(frame)</span><br><span class="line">        show_frame = cv2.cvtColor(cv2_frame, cv2.COLOR_RGB2BGR)</span><br><span class="line">        cv2.imshow(im.<span class="built_in">format</span>, show_frame)</span><br><span class="line">        cv2.waitKey(<span class="number">10</span>)   </span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用opencv的videoCaptrue来处理GIF</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showGif2</span>(<span class="params">file</span>):</span><br><span class="line">    cap = cv2.VideoCapture(file)</span><br><span class="line">    <span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">        <span class="comment"># 一帧一帧捕捉</span></span><br><span class="line">        <span class="comment"># ret=True if it finds a frame else False. </span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 对帧的操作,转为灰度图像</span></span><br><span class="line">        <span class="comment"># gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">        <span class="comment"># 显示返回的每帧</span></span><br><span class="line">        <span class="comment"># cv2.imshow(&#x27;frame&#x27;,gray)</span></span><br><span class="line">        <span class="comment"># 正常读</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;GIF&#x27;</span>,frame)</span><br><span class="line">        cv2.waitKey(<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 当所有事完成，释放 VideoCapture 对象</span></span><br><span class="line">    cap.release()</span><br><span class="line">    cv2.destroyAllWindows()    </span><br></pre></td></tr></table></figure><h4 id="图像同窗"><a href="#图像同窗" class="headerlink" title="图像同窗"></a>图像同窗</h4><p>此外，要实现图片中的效果，还需要将四张图片拼接在一起，确切地说是把他们放到同一个窗口中。又花了一天左右，终于实现了此功能，进度太慢了，主要还是不了解python和它的库……</p><h5 id="静态图片同窗"><a href="#静态图片同窗" class="headerlink" title="静态图片同窗"></a>静态图片同窗</h5><p>实现图像同窗展示，其一是用另一个库pyplot的功能。</p><p>关键代码就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 先用cv2读入文件</span></span><br><span class="line">img=cv2.imread(file)</span><br><span class="line"><span class="comment"># 再转换图片的模式，因为opencv处理图像是以BGR处理，python库是以RGB处理</span></span><br><span class="line"><span class="comment"># 若不转换模式，图片展示时颜色会异于原图</span></span><br><span class="line">img=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># 三个参数依次为目标窗口展示图片的行，列和读入图片所在位置</span></span><br><span class="line">plt.subplot(row,col,location)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"><span class="comment"># 图片上的标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;title.png&#x27;</span>)</span><br><span class="line"><span class="comment"># 用以隐藏附着于图的坐标系</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"><span class="comment"># 作用和上面一行代码一致，二者可替换</span></span><br><span class="line"><span class="comment"># plt.xticks([])</span></span><br><span class="line"><span class="comment"># plt.yticks([])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示拼接后的窗口</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>实现效果</strong></p><p><img src="/../%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/image-20221028222036144.png" alt="image-20221028222036144"></p><p>但是上面方法实现的还不够，因为还需要将一张gif存进去。而我实现gif图的展示的最终方式都是通过逐帧播放。</p><p>如果使用python库，如pillow，它打开图片的方式是下面这样，窗口要手动关闭或者借助其他库来关闭，这就使得图片不能连续播放。而opencv的imshow则可以设置cv2.waitKey(time)自动刷新，进而控制gif的播放速度。为了使gif也能和其他静态图片同窗，需要找到其他方法，但是已经很接近了。</p><p><img src="/../%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/image-20221028223134711.png" alt="image-20221028223134711"></p><h5 id="动静同窗"><a href="#动静同窗" class="headerlink" title="动静同窗"></a>动静同窗</h5><p>上课的时候，学到图片本质就是像素的堆叠。一般来说，图像是一个标准的举行，有着长宽。而矩阵也有行和列，矩阵的操作在数学和计算机中的处理都很常见且成熟，于是很自然的就把图像作为一个矩阵，把对图像的操作转换成对矩阵的操作，实际上所有的图像处理工具都是这么做的。所以接下来，我们操作的本质也是把图片当矩阵处理。</p><p>ps:这些其实都是做完实验后分析过程和结论给出的马后炮了，上课的时候我可没记住……</p><p>开始我找到的还是简单的将图片堆叠的方法，具体就是使用python的numpy库来。<strong>NumPy</strong>(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。图片像素值的读取，替换，随机剪裁，拼接等等都可以使用ndarray。对于已经习惯使用Numpy的人们来说，已经可以不使用OpenCV进行图像处理。</p><p>首先是<code>np.concatenate()</code>函数，它是用来对数列或矩阵进行合并的。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c=np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(c)   </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>此函数对数组的处理我并不是充分了解，但是先明白它是可以处理图像拼接的。</p><p><code>merge1=np.concatenate((img1,img2),axis=1)</code></p><p>此行代码的作用是实现两张的图片的横向拼接。不过在拼接前，要令被拼接的图像大小和格式一致，至少对横向拼接的两张图片而言，不要求都是正方形，但图片的纵向长度（宽）应该保持一致。</p><p><code>cv2.imshow(&#39;merge1&#39;,merge1)</code></p><p><img src="/../%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/image-20221028230419526.png" alt="image-20221028230419526"></p><p>那剩下的一张静态图和一张gif，就可以继续横向拼接。但为了美观，我们可以将其拼接为<strong>“田”</strong>字。也就是在处理gif图时，插入<code>merge2=np.concatenate((img3,frame),1)</code>来拼接图三和gif的某一帧frame，然后再将两张横向图进行纵向的拼接，最后展示。</p><p>也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> # 纵向拼接两个图像</span><br><span class="line">merge=np.concatenate((merge1,merge2),0)</span><br><span class="line"># 展示</span><br><span class="line">cv2.imshow(&#x27;GIF&#x27;,merge)</span><br><span class="line">cv2.waitKey(10)</span><br></pre></td></tr></table></figure><p>最终结果</p><p><img src="/../%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/res.gif" alt="res"></p><p>此外，还可以用 </p><p><code>merge1=np.hstack([img1,img2])</code></p><p><code>merge2=np.hstack([img3,frame])</code></p><p><code>merge=np.vstack([merge1,merge2])</code></p><p>分别替代上面的<code>np.concatenate()</code>函数，实现的效果是一样的。</p><p>那么至此，实验1-1算是做完了。</p><h4 id="保存gif"><a href="#保存gif" class="headerlink" title="保存gif"></a>保存gif</h4><p>但是写实验报告时，也许还需要贴一张gif图来展示，那么如何制作一张gif图片呢？</p><p>要制作gif图，首先要准备足够的图片作为gif或者视频的帧页，对此，我需要在前面的循环中保存每一帧图片。</p><p>在循环中插入代码</p><p><code>cv2.imwrite(&quot;./frames/frame%d.png&quot; % i,merge)</code></p><p>即可。</p><p>然后根据已有帧页，制作gif。</p><p>方法有很多，贴一个我使用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">frames = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">110</span>):</span><br><span class="line">    <span class="comment"># print(img)</span></span><br><span class="line">img = imageio.imread(<span class="string">&#x27;./frames/frame&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))  <span class="comment"># RGB格式的array</span></span><br><span class="line">frames.append(img)</span><br><span class="line">imageio.mimsave(<span class="string">&#x27;res.gif&#x27;</span>, frames, fps=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>注意不要使用这种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;data&#x27;</span></span><br><span class="line">files = [os.path.join(path, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path)]</span><br><span class="line">frames = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">img = imageio.imread(f)  <span class="comment"># RGB格式的array</span></span><br><span class="line">frames.append(img)</span><br><span class="line">imageio.mimsave(<span class="string">&#x27;res.gif&#x27;</span>, frames, fps=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>具体来说是指循环的方式。当帧数大于100时，此循环读文件的顺序并不是我们想象中的从file1到file101，而是按file1,  file100, file101, file102 ,…, file2, file3, … file99的顺序来读的，这使得合成的图片播放顺序有明显的错误。</p><p>这下才算真的而做完了1-1，下一篇更新实验1-2，图像合成。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 <a href="https://opencv.apachecn.org/#/docs/4.0.0/1.1-tutorial_py_intro">OpenCV-Python 教程简介 (apachecn.org)</a></p><p>2 <a href="http://c.biancheng.net/pillow/what-is-pillow.html">Pillow是什么 (biancheng.net)</a></p><p>3 <a href="https://blog.csdn.net/sumaliqinghua/article/details/90404173">Vscode的相对路径读取问题及处理</a></p><p>4 <a href="%5B%E3%80%90OpenCV%E3%80%91imshow()%E5%92%8CnamedWindow(">【OpenCV】imshow()和namedWindow()之间的关系</a>之间的关系，解决两个窗口问题_Running Y的博客-CSDN博客_namedwindow](<a href="https://blog.csdn.net/weixin_43243787/article/details/104755685">https://blog.csdn.net/weixin_43243787/article/details/104755685</a>))</p><p>5 <a href="https://blog.csdn.net/ITBigGod/article/details/87009082">python使用opencv或matplotlib把多张图片显示在一个窗口内</a></p><p>6 <a href="https://blog.csdn.net/weixin_43360801/article/details/109487956">OpenCV实验（1）：图像的加载与显示_</a></p><p>7<a href="https://www.cnblogs.com/xiaofeng91/p/14840128.html">pip安装第三方库报错</a></p><p>8 <a href="https://blog.csdn.net/weixin_43508499/article/details/115522755">opencv把一系列图像保存为视频、一系列图像保存为giff</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何上传本地的图片到一篇博客文章中？</title>
      <link href="/2022/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本地的md文件中插入了一些图片，上传到博客中，图片却没加载出来，控制台404错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load resource: the server responded with a status of 404 (Not Found)</span><br></pre></td></tr></table></figure><p>如何在在博客中插入图片？</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/imgs/blog学习/图片上传/bighead.jpg" width="40%" height="40%">    <br></center><span id="more"></span><h3 id="MarkDown-中图片插入"><a href="#MarkDown-中图片插入" class="headerlink" title="MarkDown 中图片插入"></a>MarkDown 中图片插入</h3><p><strong>首先，要说到markdown文件中图片的插入格式。</strong></p><p>一般，我在做笔记的时候，插入图片的方法是直接将图片通过拖拽的方式插入到md文件中，这样在md中就能直接看到插入的图片效果。</p><p>但和doc文件不一样，md文件并不是通过将整个图片插入到文章中来实现图片的展示的，而是通过在文章中插入图片的存放路径来找到资源、间接展示，可以想到，这样的方式和html文件中插入图片的方式是一致的（ 事实上，md也支持html语法）。这就解释了两个问题：</p><blockquote><p>1、为什么一篇文章中明明插入了很多张图片，实际大小确实只有几十kb？</p></blockquote><p>因为文件中只存放了图片路径，也就是只有文字，没有图片数据。</p><blockquote><p>2、为什么过一段时间，我的文章中的图片莫名其妙就裂开了？</p></blockquote><p>可能因为你写文章时用的图片是从某个地方随意摘取的，清理数据或者整理文件夹时，图片的存放位置改变或者被删除，但是文章中存放的路径没变，相当于刻舟求剑了。</p><ol><li></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/imgs/blog学习/图片上传/图片裂开.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">这是md文件中图片丢失的样子</div></center><ol start="2"><li></li></ol><p><img src="/imgs/blog%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/%E9%94%99%E8%AF%AF%E8%B7%AF%E5%BE%84.png" alt="错误路径"></p><center>  <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">这是web页面中图片丢失的样子</div></center><p>md中的图片插入的语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图像的替换文本](文件路径/图片名.png)</span><br></pre></td></tr></table></figure><p>一般来说，通过拖拽方式插入的图片，文件路径一般是图片的<strong>绝对路径</strong>，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图像的替换文本](D:\文件夹\图片名.png) </span><br></pre></td></tr></table></figure><p>还有一种，是通过<strong>相对路径</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图像的替换文本](..\图片文件夹\图片名.png) </span><br></pre></td></tr></table></figure><p>具体路径解析：</p><p>比如这篇文章的存放地址是 D: \项目文件夹\文章文件夹\文章.md</p><p>而文章中用到的图片的位置是D: \项目文件夹\图片文件夹\图片.jpg</p><p>那么使用相对路径时，就用” ..\ “来代表上一级文件夹，藏得越深，”..&quot;越多。</p><h3 id="typora图片相对路径设置"><a href="#typora图片相对路径设置" class="headerlink" title="typora图片相对路径设置"></a>typora图片相对路径设置</h3><p>首先一个问题，html中文件路径是左斜杠&#x2F;，md绝对路径用的是右斜杠\，这就导致如果想要在博客中展示图片，可能会使本地文件中看不到图片效果。</p><p>本人使用的解决方法为：在typora（编辑md文件使用的软件）中，设置图片根目录。设置的地方是格式→图像→设置图片根目录。然后把根目录设置为图片文件夹所在的地方，在文件中，图片的插入方式就是[图像的替换文本](&#x2F;文件路径&#x2F;图片名.png)，上传后，博客中图片也能正常显示了。</p><p><strong>注意，这种方法对每一个md文件都是独立的，而且与最后介绍的另一种方法冲突。</strong></p><p>eg. 下图路径：&#x2F;imgs&#x2F;blog学习&#x2F;图片上传&#x2F;设置路径.png</p><img src="/imgs/blog学习/图片上传/设置路径.png" alt="设置路径" style="zoom:50%;"><h3 id="博客中图片插入"><a href="#博客中图片插入" class="headerlink" title="博客中图片插入"></a>博客中图片插入</h3><p>再说回来，要想让同一路径下，md和网页的图片都正常显示，就还需要进行一些设置。</p><p>首先，对博客文件夹下的_config.yml做修改，将其中一个属性改为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true  //原为false</span><br></pre></td></tr></table></figure><p>然后安装一个插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>并在hexoblog\node_modules\hexo-asset-image 中将index.js文件内容替换为如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split(&#x27;.&#x27;);</span><br><span class="line">hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    var link = data.permalink;</span><br><span class="line">if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">   var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1;</span><br><span class="line">else</span><br><span class="line">   var beginPos = getPosition(link, &#x27;/&#x27;, 4) + 1;     //markdown的本地路径是xxx/x.jpg    hexo g编译后加上这句就是public/2020/05/26/xxx/xx.jpg 前4个文件+后一个图片~</span><br><span class="line">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="line">var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;];</span><br><span class="line">    for(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#x27;img&#x27;).each(function()&#123;</span><br><span class="line">if ($(this).attr(&#x27;src&#x27;))&#123;</span><br><span class="line">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br><span class="line">var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\&#x27;, &#x27;/&#x27;);</span><br><span class="line">if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">   !/^\s*\//.test(src)) &#123;</span><br><span class="line">  // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br><span class="line">  // In addition, to support multi-level local directory.</span><br><span class="line">  var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123;</span><br><span class="line">return elem != &#x27;&#x27;;</span><br><span class="line">  &#125;);</span><br><span class="line">  var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123;</span><br><span class="line">return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;;</span><br><span class="line">  &#125;);</span><br><span class="line">  if(srcArray.length &gt; 1)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(&#x27;/&#x27;);</span><br><span class="line">  $(this).attr(&#x27;src&#x27;, config.root + link + src);</span><br><span class="line">  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">console.info&amp;&amp;console.info($(this));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后博客中图片也可以正常显示了。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>但其实，上面的做法还是有点繁琐，比如图片文件与文章不在同一目录下，当文章数量变多时，插入图像就变成了比较麻烦的操作。</p><p>目标是，在文章同级文件夹下建立一个同名文件夹，使得md本地预览和网页都能正常显示。</p><p>折腾了一个下午和晚上，没找到理想方法，但下面这种算是接近。</p><p>要点：</p><ol><li><p>设置post_asset_folder: true  &#x2F;&#x2F;原为false</p></li><li><p>hexoblog\node_modules\hexo-asset-image 中将index.js文件内容替换代码</p></li><li><p>图片插入格式为![image](image.jpg) ，而非![image](文章名&#x2F;image.jpg) 。这样在博客中能正常展示，在md中虽然不能展示，但是加个文件名也能看到。此时不能设置文件根路径，否则本地也看不见。</p></li><li><p>对typora进行设置：文件→偏好设置→图像→复制到指定路径→.&#x2F;{$filename}，功能和上面一样，但是不在hexo中编辑时同样有用。</p></li><li><p>也可以是</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img  panda.jpg  image text %&#125;</span><br></pre></td></tr></table></figure></li><li><p>附加一个图片注解方式</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;img style=&quot;border-radius: 0.3125em;</span><br><span class="line">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; </span><br><span class="line">    src=&quot;地址&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    color: #999;</span><br><span class="line">    padding: 2px;&quot;&gt;注解&lt;/div&gt;</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要是图片大小控制的问题</p><p>有两种方式</p><ol><li>在asset_img外加div标签对，这个方法对md式![]()无效。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:40%;margin:auto;&quot;&gt;&#123;% asset_img bighead.jpg 图片信息描述 %&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用html的&lt;img&gt;标签，但是src中似乎只能填以source为根目录的额外建的imgs文件夹中的图片路径，直接使用图片名或者用文章同名文件夹中的图片都无效。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;img style=&quot;border-radius: 0.3125em;</span><br><span class="line">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; </span><br><span class="line">    src=&quot;/imgs/blog学习/图片上传/bighead.jpg&quot; width=&quot;40%&quot; height=&quot;40%&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>bighead.jpg</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/bighead.jpg" width="40%" height="40%"> <br></center></li><li><p>_posts\blog\博客以及md文件的图片上传\bighead.jpg </p><center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src=" \_posts\blog\博客以及md文件的图片上传\bighead.jpg " width="40%" height="40%"><br></center></li><li><p>&#x2F;_posts&#x2F;blog&#x2F;博客以及md文件的图片上传&#x2F;bighead.jpg</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/_posts/blog/博客以及md文件的图片上传/bighead.jpg" width="40%" height="40%"> <br></center></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、使用从source开始的相对路径+自己在source下建立一个img文件夹，在typora中设置图片根目录，加上上面几项设置。通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![代理图片名](/imgs/图片.png)</span><br></pre></td></tr></table></figure><p>能在文件和文章中看到同时看到图片。</p><p>2、设置文章同名文件夹，方便管理，上传网站时从图片路径中删去文件名，推荐使用。</p><p><img src="/2022/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/panda.jpg" alt="panda.jpg"></p><p>关于控制图片大小，以及插入的问题，还需要再看看。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/as3522/article/details/102972473">解决了hexo图像，但是md不显示</a></p><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">同上，但分析较全</a></p>]]></content>
      
      
      <categories>
          
          <category> blog学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DBMS课设 --物业信息管理</title>
      <link href="/2022/09/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E8%AE%BE%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/09/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E8%AE%BE%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Property Information Management（prop_info）</p><p>作业时间2022.8.14-2022.9.1，大概17天</p><span id="more"></span><h2 id="DBMS课设-–物业信息管理"><a href="#DBMS课设-–物业信息管理" class="headerlink" title="DBMS课设 –物业信息管理"></a>DBMS课设 –物业信息管理</h2><p>Property Information Management（prop_info）</p><p>作业时间2022.8.14-2022.9.1，大概17天</p><p>主要信息管理: 业主信息、房屋信息</p><p>■费用收取： 物业费、水电煤气、有线电视、供暖、车位</p><p>■信息查询及报表:  月报表、季报表、年报表</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>前端：vue2, element.ui</p><p>后端：SpringBoot, MybatisPlus</p><p>数据库：Mysql</p><p>版本信息在具体模块查看</p><h2 id="系统功能分析"><a href="#系统功能分析" class="headerlink" title="系统功能分析"></a>系统功能分析</h2><p>定位为供物业工作人员使用的信息管理系统，功能分为四大模块</p><p><img src="/imgs/DBMS/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97.png" alt="功能模块"></p><p>具体功能通过用例图来展示</p><p><img src="/imgs/DBMS/%E7%94%A8%E4%BE%8B%E5%9B%BE.png" alt="用例图"></p><h3 id="部分功能分析"><a href="#部分功能分析" class="headerlink" title="部分功能分析"></a>部分功能分析</h3><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><p>初期：房屋、业主、车位设置（3000-10000）</p><p>稳定后：缴费（月增2000-4000）</p><h4 id="限购"><a href="#限购" class="headerlink" title="限购"></a>限购</h4><p>房屋、车位限购</p><p>房屋：业主&#x3D;1：n</p><p>房屋：车位&#x3D;1：1</p><h4 id="总账单"><a href="#总账单" class="headerlink" title="总账单"></a>总账单</h4><p>累加式(级联思想)</p><p>个人缴费———个人账单更新———物业总账单更新</p><h4 id="其他安全机制"><a href="#其他安全机制" class="headerlink" title="其他安全机制"></a>其他安全机制</h4><ul><li>绑定状态下不可更新或删除（房屋、车位、业主个人信息）。</li><li>房屋、车位、业主信息的冲突检查。</li><li>暂无房产业主不可缴费，不可购入或租入车位。</li><li>仅租车位业主应缴车位费。</li><li>共同业主共享缴费清单，避免重复缴费。</li></ul><h3 id="房屋管理"><a href="#房屋管理" class="headerlink" title="房屋管理"></a>房屋管理</h3><p>房屋信息</p><p><img src="/imgs/DBMS/%E6%88%BF%E5%B1%8B%E4%BF%A1%E6%81%AF.png" alt="房屋信息"></p><p>房屋-查看业主</p><p><img src="/imgs/DBMS/%E6%88%BF%E5%B1%8B-%E6%9F%A5%E7%9C%8B%E4%B8%9A%E4%B8%BB.png" alt="房屋-查看业主"></p><p>房屋编辑&amp;新增</p><p><img src="/imgs/DBMS/%E6%88%BF%E5%B1%8B%E7%BC%96%E8%BE%91&%E6%96%B0%E5%A2%9E.png" alt="房屋编辑&amp;新增"></p><h3 id="车位管理"><a href="#车位管理" class="headerlink" title="车位管理"></a>车位管理</h3><p>车位信息</p><p><img src="/imgs/DBMS/%E8%BD%A6%E4%BD%8D%E4%BF%A1%E6%81%AF.png" alt="车位信息"></p><p>车位-查看业主</p><p><img src="/imgs/DBMS/%E8%BD%A6%E4%BD%8D-%E6%9F%A5%E7%9C%8B%E4%BF%A1%E6%81%AF.png" alt="车位-查看信息"></p><p>车位-编辑&amp;新增</p><p><img src="/imgs/DBMS/%E8%BD%A6%E4%BD%8D%E7%BC%96%E8%BE%91&%E6%96%B0%E5%A2%9E.png" alt="车位编辑&amp;新增"></p><h3 id="业主管理"><a href="#业主管理" class="headerlink" title="业主管理"></a>业主管理</h3><p>业主信息</p><p><img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB%E4%BF%A1%E6%81%AF.png" alt="业主信息"></p><p>业主-房产车位</p><p><img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB-%E6%88%BF%E4%BA%A7%E8%BD%A6%E4%BD%8D.png" alt="业主-房产车位"></p><p>业主-缴费<img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB-%E7%BC%B4%E8%B4%B9.png" alt="业主-缴费"></p><p>业主-房产车位</p><p><img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB-%E6%88%BF%E4%BA%A7%E8%BD%A6%E4%BD%8D.png" alt="业主-房产车位"></p><h3 id="物业账单"><a href="#物业账单" class="headerlink" title="物业账单"></a>物业账单</h3><p>物业账单<img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E8%B4%A6%E5%8D%95.png" alt="物业账单"></p><p>物业账单-年与季筛选</p><p><img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E8%B4%A6%E5%8D%95-%E5%B9%B4%E4%B8%8E%E5%AD%A3%E7%AD%9B%E9%80%89.png" alt="物业账单-年与季筛选"></p><p>物业账单-月筛选<img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E8%B4%A6%E5%8D%95-%E6%9C%88%E7%AD%9B%E9%80%89.png" alt="物业账单-月筛选"></p><p>报表-折线</p><p><img src="/imgs/DBMS/%E6%8A%A5%E8%A1%A8-%E6%8A%98%E7%BA%BF.png" alt="报表-折线"></p><p>报表-饼</p><p><img src="/imgs/DBMS/echart-pie.png" alt="报表-饼"></p><h2 id="前端prop-vue"><a href="#前端prop-vue" class="headerlink" title="前端prop_vue"></a>前端prop_vue</h2><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>1、环境配置：</p><p>node  v16.13.1</p><p>npm   v8.14.0</p><p>vue     @vue&#x2F;cli 5.0.8</p><p>2、使用@vue&#x2F;cli脚手架构建一个vue2项目</p><p>地址：D:\code\DBMS\prop_info\prop_vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1）将vue项目建在D盘的目标文件夹下，cmd中进入该目录，输入新建项目命令 vue create 项目名，执行后会自动生成</span><br><span class="line">vue项目。</span><br><span class="line">2）运行vue项目</span><br><span class="line">3）浏览器访问项目</span><br><span class="line">项目运行成功后浏览器访问地址 http://localhost:8080</span><br><span class="line">4）查看生成的vue项目结构</span><br><span class="line"></span><br><span class="line">&gt; vue create prop_info(名字不能含有大写字母npm)</span><br><span class="line">&gt; npm run serve</span><br><span class="line"></span><br><span class="line">安装的cli插件：router, vuex, bable</span><br><span class="line"></span><br><span class="line">5）使用IntelliJ IDEA打开并运行该vue项目</span><br><span class="line">点击菜单栏“Add Configurations”设置运行命令npm</span><br><span class="line">点击“serve”旁边运行按钮</span><br></pre></td></tr></table></figure><ol start="3"><li>引入element.ui（在main.js中引入）</li></ol><p><a href="https://element-plus.gitee.io/zh-CN/guide/installation.html#%E4%BD%BF%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8">安装 | Element Plus (gitee.io)</a></p><p>element.ui只适配Vue2，支持Vue3的是Element.plus</p><ol start="4"><li><p>跨域设置</p><p> 前后端应该占用本地不同的端口，同一端口会冲突。</p><p> 通过这个文件，实现前后端的连接。</p><p> 位置在vue文件夹下，和package.json、src文件夹平级</p><p> 文件名 vue.config.js</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 跨域配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;                //记住，别写错了devServer//设置本地默认端口  选填</span><br><span class="line">        // port: 8081,</span><br><span class="line">        proxy: &#123;                 //设置代理，必须填</span><br><span class="line">            &#x27;/api&#x27;: &#123;              //设置拦截器  拦截器格式   斜杠+拦截器名字，名字可以自己定</span><br><span class="line">                target: &#x27;http://localhost:8081&#x27;,     //代理的目标地址</span><br><span class="line">                changeOrigin: true,              //是否设置同源，输入是的</span><br><span class="line">                pathRewrite: &#123;                   //路径重写</span><br><span class="line">                    &#x27;/api&#x27;: &#x27;&#x27;                     //选择忽略拦截器里面的单词</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个页面</p><p> 需要在router的index.js中添加路由，在导航中设置路径</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/house&#x27;,</span><br><span class="line">    name: &#x27;House&#x27;,</span><br><span class="line">    component: House</span><br><span class="line">&#125;</span><br><span class="line">      &lt;el-menu-item index=&quot;/house&quot; style=&quot;font-size: 20px &quot;&gt;&lt;i class=&quot;el-icon-s-home&quot;&gt;&lt;/i&gt; 房屋管理&lt;/el-menu-item&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>前端东西很多且复杂，讲不清楚。有时间还是自己学学，参考自己做的项目。</p><p>此次的数据库课设，让我基本能独立搭建好一个管理系统的前端页面，不过vue的很多属性我确实也不会用。但就我用到的东西而言，已经能自己找出bug并修复了。</p><p>组件很重要，但是不太熟练。</p><p>奥，比较重要的一点是学会使用已有的前端开源框架，比如若依，这样省了很多事。就算不用，参考一些功能设计和ui也会有很大帮助。虽然这个是我做完项目之后，跟人交流时才知道的。</p><p><a href="http://www.twom.top/">RuoYi 若依官方网站 </a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>如何在页头的content中自定义变量</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">开始用的tag</span><br><span class="line">&lt;el-page-header @back=&quot;back&quot; content=&quot;房屋&amp;业主绑定&quot; style=&quot;color: blue&quot;&gt;&lt;/el-page-header&gt;</span><br><span class="line">&lt;el-tag size=&quot;medium&quot;&gt;房屋编号:&#123;&#123; this.housenumber &#125;&#125;&lt;/el-tag&gt;</span><br><span class="line"></span><br><span class="line">后来</span><br><span class="line">&lt;el-page-header @back=&quot;back&quot; content=&#123;&#123;this.headercontent&#125;&#125; style=&quot;color: blue&quot;&gt;&lt;/el-page-header&gt;</span><br><span class="line"></span><br><span class="line">报错，提示</span><br><span class="line">修改content=&#123;&#123;this.headercontent&#125;&#125;</span><br><span class="line">为:content=this.headercontent</span><br></pre></td></tr></table></figure><blockquote><p>如何引入echarts？</p></blockquote><p><a href="https://blog.csdn.net/qq_43471802/article/details/109136061?utm_medium=distribute.pc_category.none-task-blog-hot-2.nonecase&depth_1-utm_source=distribute.pc_category.none-task-blog-hot-2.nonecase&request_id=">如何在Vue中使用Echarts可视化库_</a></p><h2 id="后端prop-serve"><a href="#后端prop-serve" class="headerlink" title="后端prop_serve"></a>后端prop_serve</h2><p>SpringBoot+MybatisPlus</p><p>版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot  2.7.2</span><br><span class="line">MybatisPlus 3.5.2</span><br><span class="line">jdk 1.8</span><br></pre></td></tr></table></figure><h3 id="项目搭建-1"><a href="#项目搭建-1" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>地址D:\code\DBMS\prop_info\prop_serve</p><p>(若使用idea操作，在大文件夹下D:\code\DBMS\prop_info创建一个子模块maven即可)</p><p>方式一：直接使用idea创建（似乎因为网络问题，我失败了几次）</p><ol><li><p><a href="https://www.cnblogs.com/ljsh/p/14279992.html">使用SpringBoot搭建Web项目</a></p></li><li><p>创建spring_boot项目时，出现Error message: Cannot download ‘<a href="https://start.spring.io‘/">https://start.spring.io‘</a>: Read timed out，即连不上网络访问<a href="https://start.spring.io，怀疑是家里移动网的问题，按[方法](https://blog.csdn.net/weixin_45721753/article/details/125933528)更换其为阿里云的地址即可https://start.aliyun.com">https://start.spring.io，怀疑是家里移动网的问题，按[方法](https://blog.csdn.net/weixin_45721753/article/details/125933528)更换其为阿里云的地址即可https://start.aliyun.com</a></p></li><li><p>添加依赖，位置pom.xml</p></li><li><p>springweb, Lombok, MyBatis plus</p></li></ol><p>  方式二：通过[官网](<a href="https://start.spring.io/">Spring Initializr</a>)来创建，类似vue</p><p>  （网络问题再现，移动网mmp，挂了梯子才行。</p><p>Could not connnect to server. Please check your network.</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><h4 id="项目细节初见"><a href="#项目细节初见" class="headerlink" title="项目细节初见"></a>项目细节初见</h4><p>初见</p><p>先准备好几个文件夹，用于放不同类型的java文件</p><p>如entity，存放项目的实体类；controller存放业务功能类；mapper存放mapper文件。</p><h5 id="entity类"><a href="#entity类" class="headerlink" title="entity类"></a>entity类</h5><p>entity类注解，以Owner类为例。了解更多搜索“Mybatis-Plus实体类注解”，如<a href="https://blog.csdn.net/qq_42758288/article/details/113888770">Mybatisplus常用注解_袁浩东的博客-CSDN博客_mybatisplus注解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Data//使用lombok插件，省略了getter和setter的书写</span><br><span class="line">@TableName(&quot;owner&quot;)//表名与数据库中的表对应一致</span><br><span class="line">public class Owner &#123;</span><br><span class="line">//主键的注解</span><br><span class="line">    @TableId(value=&quot;seleId&quot;,type = IdType.AUTO)</span><br><span class="line">    private Long seleId;//作为选择数据的标记</span><br><span class="line"></span><br><span class="line">//其他字段的注解，当二者不一致时必须要用，比如数据库中字段是id_num，注解就写@TableField(&quot;id_num&quot;)。一致时可以省略。</span><br><span class="line"> @TableField(&quot;idnum&quot;)</span><br><span class="line">    private String idnum;//身份证</span><br><span class="line">    private String name;//姓名</span><br><span class="line">    private int gender;//性别</span><br><span class="line">    private String phone;//联系方式</span><br><span class="line">    private String work;//工作单位</span><br><span class="line">    private int family;//家庭人数</span><br><span class="line">//    不要了</span><br><span class="line">//    @TableField(&quot;houseProp&quot;)</span><br><span class="line">//    private int houseProp;//名下房产数</span><br><span class="line">//    @TableField(&quot;parkProp&quot;)</span><br><span class="line">//    private int parkProp;//名下私有车位数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h5><p>格式如下，其中@Mapper注解要看情况，有两种方式。</p><p>一、每个mapper类前都加@Mapper注解；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件名  OwnerMapper.interface</span><br><span class="line">@Mapper</span><br><span class="line">public interface OwnerMapper extends BaseMapper&lt;Owner&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、在项目启动类xxxApplication.java 前写@MapperScan(“com.prop_serve.mapper”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication//启动类的必要注解</span><br><span class="line">@MapperScan(&quot;com.prop_serve.mapper&quot;)</span><br><span class="line">public class PropServeApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(PropServeApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实使用第二种的MapperScan是最省力的，因为如果不在这里写，每个mapper都要自己手动注释@Mapper。</p><p><strong>注意：二者都存在的话，就会产生重复注入警告</strong></p><h5 id="controller类"><a href="#controller类" class="headerlink" title="controller类"></a>controller类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController  //必要的注解</span><br><span class="line">@RequestMapping(&quot;/owner&quot;)//前端访问路径</span><br><span class="line">public class OwnerControl &#123;</span><br><span class="line">@Resource  //mapper引导，每用一个不同的mapper，就加一个注解。</span><br><span class="line">    OwnerMapper ownerMapper;</span><br><span class="line">    </span><br><span class="line">@RequestMapping(&quot;/owner&quot;)//进一步细分路径</span><br><span class="line">public void Test()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="common类"><a href="#common类" class="headerlink" title="common类"></a>common类</h5><p>存放其他的一些配置文件类，比如result.java（对返回结果进行包装）和MybatisPlusConfig.java  分页插件</p><h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p>在java&#x2F;resource 中新建文件 application.yml，用于设置端口和连接数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  数据库连接配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/prop_info?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false &amp;serverTimezone=Asia/Shanghai #注意时区设置</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  check-config-location: true    #</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml #mapper位置</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true #开启驼峰命名</span><br><span class="line">    type-aliases-package: com.prop_serve.entity #实体类位置</span><br></pre></td></tr></table></figure><h4 id="增加功能"><a href="#增加功能" class="headerlink" title="增加功能"></a>增加功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RequestBody 参数注解，对应的参数需要是一个实体类，通过mapper的insert方法插入数据</span><br><span class="line"></span><br><span class="line">//    增加业主</span><br><span class="line">    @PostMapping(&quot;/addOwner&quot;)</span><br><span class="line">    public Result&lt;?&gt; addOwner(@RequestBody Owner newOwner) &#123;</span><br><span class="line">        QueryWrapper&lt;Owner&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(&quot;idnum&quot;, newOwner.getIdnum());</span><br><span class="line"></span><br><span class="line">        owner = ownerMapper.selectOne(queryWrapper);</span><br><span class="line">        if (owner != null) &#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;重复的业主证件号!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ownerMapper.insert(newOwner);</span><br><span class="line">        System.out.println(&quot;新增业主&quot; + newOwner.getIdnum());</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="编辑功能"><a href="#编辑功能" class="headerlink" title="编辑功能"></a>编辑功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 通过mapper的updateById方法更新数据，前提是对象中含有主键。</span><br><span class="line"> 如果没有，就先通过参数的一些属性，尝试从数据库中找到符合特点的数据（selectOne, selectList,selectPage等），然后进行更新。</span><br><span class="line"> </span><br><span class="line"> @PutMapping(&quot;/editOwner&quot;)</span><br><span class="line">    public Result&lt;?&gt; editOwner(@RequestBody Owner owner) &#123;</span><br><span class="line">//        先看有没有绑定房屋，如果有就阻止</span><br><span class="line">        QueryWrapper&lt;HouseBinding&gt; q1=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q1.eq(&quot;idnum&quot;,owner.getIdnum());</span><br><span class="line">//        能在房屋绑定表中找到数据，就阻止</span><br><span class="line">        if (houseBindingMapper.selectOne(q1)!=null)&#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;请先解除当前业主的房屋绑定!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        如果把身份证改成了另一人的，要阻止</span><br><span class="line">//        先按seleId找到原来数据，再进行对比</span><br><span class="line">        QueryWrapper&lt;Owner&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(&quot;idnum&quot;, owner.getIdnum());</span><br><span class="line">        Owner h = ownerMapper.selectOne(queryWrapper);</span><br><span class="line">        //如果新证件已经被注册过 且注册者不是自己，就阻止</span><br><span class="line">        if (h != null&amp;&amp;h.getSeleId()!=owner.getSeleId()) &#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;重复的业主证件号!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ownerMapper.updateById(owner);</span><br><span class="line">        System.out.println(&quot;更新业主&quot; + owner.getIdnum());</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1.通过querry 找到对应数据，使用delete()方法：ownerMapper.delete(q2)，使用forEach遍历批量删除数据;</span><br><span class="line">2.传入的是个对象，直接用deleteById()，批量删除为deleteBatchIds()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    单个删除用户</span><br><span class="line">    @DeleteMapping(&quot;/deleteSingle/&#123;idnum&#125;&quot;)</span><br><span class="line">    public Result&lt;?&gt; deleteSingle(@PathVariable String idnum) &#123;</span><br><span class="line">        //        先看有没有绑定房屋，如果有就阻止</span><br><span class="line">        QueryWrapper&lt;HouseBinding&gt; q1=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q1.eq(&quot;idnum&quot;,idnum);</span><br><span class="line">//        能在房屋绑定表中找到数据，就阻止</span><br><span class="line">        if (houseBindingMapper.selectOne(q1)!=null)&#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;请先解除当前业主的房屋绑定!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;Owner&gt; q2=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q2.eq(&quot;idnum&quot;,idnum);</span><br><span class="line">        ownerMapper.delete(q2);</span><br><span class="line">        System.out.println(&quot;删除业主&quot; + idnum);</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //    批量删除业主</span><br><span class="line">    @PostMapping(&quot;/deleteBatch&quot;)</span><br><span class="line">    public Result&lt;?&gt; deleteBatch(@RequestBody List&lt;String&gt; idnum) &#123;</span><br><span class="line">        //  删除业主前，检查是否还存在绑定房屋，如果有，则不能删除</span><br><span class="line">        for (String s : idnum) &#123;</span><br><span class="line">            QueryWrapper&lt;HouseBinding&gt; q=new QueryWrapper&lt;&gt;();</span><br><span class="line">            q.eq(&quot;idnum&quot;,s);</span><br><span class="line">            HouseBinding h=houseBindingMapper.selectOne(q);</span><br><span class="line">            if (h!=null)&#123;</span><br><span class="line">                String s1=&quot;删除失败，请先解除业主&quot;+ owner.getIdnum()+&quot;的房屋绑定！&quot;;</span><br><span class="line">                return Result.error(&quot;-1&quot;,s1);</span><br><span class="line">            &#125;</span><br><span class="line">            QueryWrapper&lt;Owner&gt; q1=new QueryWrapper&lt;&gt;();</span><br><span class="line">            q1.eq(&quot;idnum&quot;,s);</span><br><span class="line">            ownerMapper.delete(q1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;批量删除业主&quot;);</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//    分页+获取用户表，支持按证件号查找个人</span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result&lt;?&gt; findPage(@RequestParam(defaultValue = &quot;1&quot;) Integer pageNum,</span><br><span class="line">                              @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize,</span><br><span class="line">                              @RequestParam(defaultValue = &quot;&quot;) String search) &#123;</span><br><span class="line">//        LambdaQueryWrapper&lt;Owner&gt; wrapper = Wrappers.&lt;Owner&gt;lambdaQuery().like(Owner::getIdnum, search);</span><br><span class="line">        //        查询数据不为空，从第一页开始展示</span><br><span class="line">        if (!search.isEmpty())&#123;</span><br><span class="line">            pageNum=1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;Owner&gt; q=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q.like(&quot;idnum&quot;, search).or().like(&quot;name&quot;, search);</span><br><span class="line"></span><br><span class="line">        Page&lt;Owner&gt; page = ownerMapper.selectPage(new Page&lt;&gt;(pageNum, pageSize), q);</span><br><span class="line"></span><br><span class="line">        return Result.success(page);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>说不太清楚，看文件吧</p><p>此处是LIst转page的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分页函数</span><br><span class="line"> *</span><br><span class="line"> * @param currentPage 当前页数</span><br><span class="line"> * @param pageSize    每一页的数据条数</span><br><span class="line"> * @param list        要进行分页的数据列表</span><br><span class="line"> * @return 当前页要展示的数据</span><br><span class="line"> * @author pochettino</span><br><span class="line"> */</span><br><span class="line">private Page getPages(Integer currentPage, Integer pageSize, List list) &#123;</span><br><span class="line">    Page page = new Page();</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int size = list.size();</span><br><span class="line">    if (pageSize &gt; size) &#123;</span><br><span class="line">        pageSize = size;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pageSize != 0) &#123;</span><br><span class="line">        // 求出最大页数，防止currentPage越界</span><br><span class="line">        int maxPage = size % pageSize == 0 ? size / pageSize : size / pageSize + 1;</span><br><span class="line">        if (currentPage &gt; maxPage) &#123;</span><br><span class="line">            currentPage = maxPage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前页第一条数据的下标</span><br><span class="line">    int curIdx = currentPage &gt; 1 ? (currentPage - 1) * pageSize : 0;</span><br><span class="line"></span><br><span class="line">    List pageList = new ArrayList();</span><br><span class="line">    // 将当前页的数据放进pageList</span><br><span class="line">    for (int i = 0; i &lt; pageSize &amp;&amp; curIdx + i &lt; size; i++) &#123;</span><br><span class="line">        pageList.add(list.get(curIdx + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page.setCurrent(currentPage).setSize(pageSize).setTotal(list.size()).setRecords(pageList);</span><br><span class="line"></span><br><span class="line">    return page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><blockquote><p>项目一直卡在resolving dependencies of xxx, 或者说resolving Maven dependencies</p></blockquote><p>解决方式参考</p><p><a href="https://blog.csdn.net/sun_luming/article/details/95327506">IDEA新建项目卡在下载Resolving dependencies of xxx</a></p><blockquote><p>Cannot resolve symbol ‘SpringBootApplication</p></blockquote><p>很可能是因为没连数据库但是使用了mybatis-plus依赖的缘故，总之先注释掉m-p就行了。</p><p>其他情况，Maven设置中左上角刷新和install</p><p>以及</p><p><a href="https://blog.csdn.net/yexiaomodemo/article/details/119238320">IDEA “Cannot resolve symbol” 解决办法_悟能的师兄的博客-CSDN博客_cannot resolve symbol</a></p><blockquote><p>后端接口的验证方法</p></blockquote><p>学习使用apipost工具</p><blockquote><p> 批量删除功能无效</p></blockquote><p>后端参数RequestBody注解，但误用了DeleteMapping而不是RequestMapping</p><h2 id="数据库prop-info"><a href="#数据库prop-info" class="headerlink" title="数据库prop_info"></a>数据库prop_info</h2><p>Server version: 8.0.27 MySQL Community Server - GPL</p><p>使用方式：以管理员身份运行cmd窗口，输入net start mysql 或net stop mysql来启动mysql</p><p>mysql连接方式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL -uxxx -pyyy  #xxx和yyyy分别是用户名和密码</span><br></pre></td></tr></table></figure><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>ER图和表结构</strong></p><p>说明：表中设置seleId选择标记的作用是，实现对unique属性的编辑。比如说要修改一个人的证件号和其他身份信息，如果把证件号作为主键，后端实现修改功能时就会很复杂，而且这样的操作也是危险的，因为它是与其他信息有所关联的。</p><h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><p><img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FER%E5%9B%BE%E5%85%A8%E5%B1%9E%E6%80%A7.png" alt="物业管理系统ER图全属性"></p><h4 id="业主表owner"><a href="#业主表owner" class="headerlink" title="业主表owner"></a>业主表owner</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增，非空</td><td>int(10) unsigned zerofill NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>name</td><td>非空</td><td>varchar(50) NOT NULL</td><td>业主姓名</td></tr><tr><td>gender</td><td>非空</td><td>int NOT NULL</td><td>业主性别</td></tr><tr><td>idnum</td><td>非空，unique</td><td>varchar(50) NOT NULL</td><td>证件号</td></tr><tr><td>phone</td><td>非空</td><td>varchar(50) NOT NULL</td><td>联系方式</td></tr><tr><td>work</td><td>非空</td><td>varchar(100) NOT NULL</td><td>工作单位</td></tr><tr><td>family</td><td>默认“1”</td><td>int NULL</td><td>家庭人数</td></tr></tbody></table><p>说明：表中设置seleId选择标记的作用是，实现对unique属性的编辑和校验。</p><p>比如说要修改一个人的证件号和其他身份信息，如果把证件号作为主键，后端实现修改功能时就会很复杂，而且这样的操作也是危险的，因为它是与其他信息有所关联的。</p><h4 id="房屋表house"><a href="#房屋表house" class="headerlink" title="房屋表house"></a>房屋表house</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增，非空</td><td>int NOT NULL</td><td>标记，作为选中数据的标记，自增</td></tr><tr><td>housenumber</td><td>unique，非空</td><td>varchar(10) NOT NULL</td><td>房屋编号，格式为_b_u_f_d</td></tr><tr><td>housetype</td><td>非空</td><td>varchar(10) NOT NULL</td><td>户型，格式为_r_h_t</td></tr><tr><td>area</td><td>非空，默认40（最小40）</td><td>float NOT NULL</td><td>面积,单位平米</td></tr><tr><td>hnum</td><td>默认0</td><td>int NULL</td><td>业主人数，默认为0</td></tr><tr><td>h_building</td><td></td><td>varchar(10) NULL</td><td>栋</td></tr><tr><td>h_unit</td><td></td><td>varchar(10) NULL</td><td>单元</td></tr><tr><td>h_floor</td><td></td><td>varchar(10) NULL</td><td>层</td></tr><tr><td>h_door</td><td></td><td>varchar(10) NULL</td><td>门牌（户）</td></tr><tr><td>parking</td><td>默认“无”</td><td>varchar(20) NULL</td><td>绑定车位</td></tr><tr><td>occupation</td><td>默认“0”</td><td>int NULL</td><td>车位状态</td></tr></tbody></table><h4 id="房产绑定表-housebinding"><a href="#房产绑定表-housebinding" class="headerlink" title="房产绑定表 housebinding"></a>房产绑定表 housebinding</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>idnum</td><td>主键，unique</td><td>varchar(50) NOT NULL</td><td>业主证件号，每个人限购一套房，所以主键为证件号更方便</td></tr><tr><td>housenumber</td><td></td><td>varchar(50) NOT NULL</td><td>房屋编号，同一套房可以有多个共同业主共享产权</td></tr></tbody></table><h4 id="车位表-parkinglot"><a href="#车位表-parkinglot" class="headerlink" title="车位表 parkinglot"></a>车位表 parkinglot</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增，非空</td><td>int NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>parking</td><td>unique，非空</td><td>varchar(20) NOT NULL</td><td>停车位编号</td></tr><tr><td>occupation</td><td>非空，默认“0”</td><td>int(1) unsigned zerofill NULL</td><td>转让情况， 0表可租或可售，1表已租，2表已售出</td></tr></tbody></table><h4 id="车位绑定parkbinding"><a href="#车位绑定parkbinding" class="headerlink" title="车位绑定parkbinding"></a>车位绑定parkbinding</h4><table><thead><tr><th>Field</th><th></th><th>约束Type</th><th>Comment</th></tr></thead><tbody><tr><td>parking</td><td>主键，unique，非空</td><td>varchar(20) NOT NULL</td><td>停车位</td></tr><tr><td>housenumber</td><td>非空</td><td>varchar(10) NOT NULL</td><td>房屋号，小区业主才能购买或者租入车位，一户最多一个</td></tr><tr><td>occupation</td><td>非空</td><td>int NOT NULL</td><td>所属情况（2表购入，1表租入）</td></tr></tbody></table><p>一房一车，但是绑定时输入的是业主的证件号，填入数据库的是查询到的绑定的房屋编号</p><h4 id="房屋缴费表perfee"><a href="#房屋缴费表perfee" class="headerlink" title="房屋缴费表perfee"></a>房屋缴费表perfee</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增</td><td>int NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>housenumber</td><td></td><td>varchar(10) NOT NULL</td><td>房屋编号</td></tr><tr><td>chargetime</td><td></td><td>date NULL</td><td>收款月份</td></tr><tr><td>expectfee</td><td>默认0</td><td>double NULL</td><td>预计总费</td></tr><tr><td>property</td><td>默认0</td><td>double NULL</td><td>物业费</td></tr><tr><td>water</td><td>默认0</td><td>double NULL</td><td>水</td></tr><tr><td>elec</td><td>默认0</td><td>double NULL</td><td>电</td></tr><tr><td>gas</td><td>默认0</td><td>double NULL</td><td>天然气</td></tr><tr><td>tv</td><td>默认0</td><td>double NULL</td><td>电视</td></tr><tr><td>heating</td><td>默认0</td><td>double NULL</td><td>暖气</td></tr><tr><td>park</td><td>默认0</td><td>double NULL</td><td>车位费（租）</td></tr></tbody></table><h4 id="物业总缴费表"><a href="#物业总缴费表" class="headerlink" title="物业总缴费表"></a>物业总缴费表</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增</td><td>int NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>chargetime</td><td>unique</td><td>date NULL</td><td>收款月份，设为独特防止冲突</td></tr><tr><td>totalf</td><td>默认0</td><td>double NULL</td><td>预计总费</td></tr><tr><td>property</td><td>默认0</td><td>double NULL</td><td>物业费</td></tr><tr><td>water</td><td>默认0</td><td>double NULL</td><td>水</td></tr><tr><td>elec</td><td>默认0</td><td>double NULL</td><td>电</td></tr><tr><td>gas</td><td>默认0</td><td>double NULL</td><td>天然气</td></tr><tr><td>tv</td><td>默认0</td><td>double NULL</td><td>电视</td></tr><tr><td>heating</td><td>默认0</td><td>double NULL</td><td>暖气</td></tr><tr><td>park</td><td>默认0</td><td>double NULL</td><td>车位</td></tr></tbody></table><h3 id="模拟数据批量生成"><a href="#模拟数据批量生成" class="headerlink" title="模拟数据批量生成"></a>模拟数据批量生成</h3><p>一、使用网站或其他工具</p><p><a href="https://www.toolscat.com/dev/data-generator">批量生成模拟数据在线工具—工具猫 (toolscat.com)</a></p><p>二、结合网站工具和excel、txt模拟复杂格式的数据</p><p><a href="https://blog.csdn.net/qq_27468351/article/details/79728233">使用Excel批量生成sql,包括日期格式_我的屎壳郎君的博客-CSDN博客</a></p><p>如时间，特殊格式的字符串，求和，字符串合并</p><p>excel很强大，数据可以按格式自动赋值传递。</p><p>时间类的字段直接用是数字类型的，如果想保留为字符串，就先复制到txt文件中，再设置目标行的段落格式为文本类型，然后粘贴即可。</p><p>总之，模拟好数据后，总要转化成sql脚本。</p><p>方法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=CONCATENATE(&quot;insert ignore into TableName (属性1,属性2,属性3) value (&#x27;&quot;&amp;B2&amp;&quot;&#x27;,&quot;&amp;C2&amp;&quot;,&quot;&amp;D2&amp;&quot;);&quot;)</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">1、 =CONCATENATE(&quot;sql-script&quot;) sql-script指的是sql脚本</span><br><span class="line">2、 insert ignore into TableName的ignore指的是忽略插入错误的行，执行所有没有问题的数据，这在批量执行时有用。</span><br><span class="line">3、 &quot;&amp;C2&amp;&quot; 双引号中包裹的是excel表格中目标数据位置，如果是字符串，还要套上一层单引号&#x27;&quot;&amp;B2&amp;&quot;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World！</title>
      <link href="/2022/07/20/22/%E6%9D%82%E8%B0%88/test/%E6%9D%82%E8%B0%88/"/>
      <url>/2022/07/20/22/%E6%9D%82%E8%B0%88/test/%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>测试</p><span id="more"></span><p>在终于换好了主题，博客也基本搭好了。大概在21年暑假就准备做的博客，因为各种包和主题的问题屡屡失败，最终不了了之。</p><p>这次折腾了大半天。本来想用claudia主题，但是似乎某些必要的包过时了，主题用不了，先用着Next主题吧。</p><p>此后博客的内容就是对本人的学习和项目的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
