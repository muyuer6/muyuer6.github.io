<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenCV之几何变换和变形</title>
      <link href="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>实验3–图像滤波处理</p><span id="more"></span><h2 id="图像滤波处理"><a href="#图像滤波处理" class="headerlink" title="图像滤波处理"></a>图像滤波处理</h2><h2 id="3-1实现图像的高斯滤波处理"><a href="#3-1实现图像的高斯滤波处理" class="headerlink" title="3-1实现图像的高斯滤波处理"></a>3-1实现图像的高斯滤波处理</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>1）通过调整高斯函数的标准差(sigma)来控制平滑程度；</p><p>给定函数：<code>void Gaussian(const MyImage &amp;input, MyImage &amp;output, double sigma);</code></p><p>2）滤波窗口大小取为<code>[6sigma-1]/2*2+1</code>，[.]表示取整；</p><p>3）利用二维高斯函数的行列可分离性进行加速；</p><ul><li>先对每行进行<strong>一维高斯滤波</strong>，再对结果的每列进行同样的<strong>一维高斯滤波</strong>；</li><li>空间滤波&#x3D;图像卷积；</li><li>高斯滤波&#x3D;以高斯函数为卷积核的图像卷积。</li></ul><div style="width:80%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/clip_image002.jpg" class></div><p>预期效果</p><div style="width:80%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/clip_image002-16690886383501.jpg" class></div><h3 id="二维高斯滤波"><a href="#二维高斯滤波" class="headerlink" title="二维高斯滤波"></a>二维高斯滤波</h3><p>关于第二步滤波窗口的公式<code>[6sigma-1]/2*2+1</code>，为什么要先乘2再除2。</p><p>因为在很多C++中，整型数除2得到的结果仍为整型，再乘以2，加1，能使<strong>窗口边长为奇数</strong>个单位，但在python中，整数除法运算会自动转化为浮点数 ，以上操作无效，还需要额外取整。至于为什么要使边长为奇数（如3x3，5x5），原因就在于要以被处理像素点为中心，使像素取值能相对均匀。</p><p>先按照函数，实现一个行列不分离的高斯滤波器。</p><p>根据公式<code>[6sigma-1]/2*2+1</code>，可通过<code>kernelSize= int(int(6*sigma-1)//2)*2+1</code>得滤波窗口大小，<code>//</code>表示整除。然后构建<code>Gaussian Kernel</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Kernel=np.zeros((kernelSize,kernelSize),dtype=np.<span class="built_in">float</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 使中心点坐标(kernelSize // 2,)转为(0, 0)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 为图片四周增加宽度等于 滤波器半径 的边缘</span></span><br><span class="line">pad=kernelSize // <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(kernelSize):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(kernelSize):</span><br><span class="line">        _x = x - pad</span><br><span class="line">        _y = y - pad</span><br><span class="line">        Kernel[y, x] = np.exp( -(_x ** <span class="number">2</span> + _y ** <span class="number">2</span>) / (<span class="number">2</span> * (sigma ** <span class="number">2</span>)))</span><br><span class="line">Kernel /= (<span class="number">2</span> * np.pi*(sigma**<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">Kernel /= Kernel.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>获得<code>kernel</code>后就可以对图像进行平滑操作<code>filtering</code>了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#改变参数</span><br><span class="line">def filter1():</span><br><span class="line">    # 复制最边缘像素</span><br><span class="line">    transImage = cv2.copyMakeBorder(imgSrc, pad, pad, pad, pad,</span><br><span class="line">                                    borderType=cv2.BORDER_REPLICATE)  </span><br><span class="line">    # # filtering 平滑操作</span><br><span class="line">    for y in range(h):</span><br><span class="line">        for x in range(w):</span><br><span class="line">            for k in range(channel): </span><br><span class="line">                imgDst[y, x, k]=np.sum(Kernel*transImage[y:y + kernelSize, x:x + kernelSize,k])</span><br><span class="line">    cv2.imshow(&#x27;1 Parameter Changed&#x27;,imgDst) </span><br><span class="line">    </span><br><span class="line">#不能改变参数   </span><br><span class="line">def filter2():</span><br><span class="line">    imgDst = np.zeros((h + pad * 2, w + pad * 2, channel), dtype=np.float)</span><br><span class="line">    imgDst[pad: pad + h, pad: pad + w] = imgSrc.copy().astype(np.float)</span><br><span class="line">    tmpSrc=imgDst.copy()</span><br><span class="line">    # # filtering 平滑操作</span><br><span class="line">    for y in range(h):</span><br><span class="line">        for x in range(w):</span><br><span class="line">            for k in range(channel): </span><br><span class="line">                imgDst[pad + y, pad + x, k]= np.sum(Kernel*tmpSrc[y:y + kernelSize, x:x + kernelSize,k])</span><br><span class="line">    # 处理越界像素数据 </span><br><span class="line">    # imgDst = np.clip(imgDst, 0, 255)</span><br><span class="line">    imgDst = imgDst[pad: pad + h, pad: pad + w].astype(np.uint8)</span><br><span class="line">    cv2.imshow(&#x27;2 Parameter Unchanged&#x27;,imgDst)</span><br></pre></td></tr></table></figure><p>上面是两种平滑方式，其中<code>filter2</code>并不能实现给定函数<code>Gaussian(const MyImage &amp;input, MyImage &amp;output, double sigma)</code>，即传入的图片并不能得到更改。函数内调用<code>cv2.imshow()</code>时可以正常显示，但是在主函数中，<code>imgDst</code>为纯黑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imgDst=np.zeros(<span class="built_in">list</span>(imgSrc.shape),dtype=<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">Gaussian(imgSrc,imgDst,sigma=<span class="number">1.2</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;can only see black&#x27;</span>,imgDst)</span><br></pre></td></tr></table></figure><p>通过<code>copy</code>方法或者直接赋值是无法改变<code>output</code>的值的，其本质是使两个变量指向同一个地址。这是程序的参数传递性质决定的。保持函数<code>filter2</code>不变，可以通过<code>return temp</code>，然后在主函数中写<code>img=Guassian(imgSrc,anyImg,sigma)</code>实现图片的改变。</p><p>一个<code>Kernel</code>算法，两个<code>filter</code>算法(当然<code>filter1</code>相对来说更好，达到了预期效果)。二者呈现不同效果的主要原因还是在于python处理矩阵时的方式（或者说人编写程序的方式）。由于本人对其缺乏了解，尝试和改变了很多次，脑袋还是有些晕乎。两个<code>filter</code>交换一些写法，会出现各种行列匹配错误的问题。折腾了一个下午和晚上，属实费劲，真菜啊我。</p><div style="width:40%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221125002829110.png" class></div><h3 id="一维高斯滤波"><a href="#一维高斯滤波" class="headerlink" title="一维高斯滤波"></a>一维高斯滤波</h3><p>二维高斯分布函数：</p><p>$$G(x,y)&#x3D;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}$$</p><p>二维高斯函数的行列可分离性的公式推导；</p><p>$$ \begin{equation}\begin{split}G(x,y)&amp;&#x3D;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}\&amp;&#x3D;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2}{2\sigma^2}-\frac{y^2}{2\sigma^2}}\&amp;&#x3D;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2}{2\sigma^2}}*\frac{1}{2\pi\sigma^2}e^{-\frac{y^2}{2\sigma^2}}\&amp;&#x3D;G(x)*G(y)\end{split}\end{equation} $$</p><h4 id="高斯核行列分离"><a href="#高斯核行列分离" class="headerlink" title="高斯核行列分离"></a>高斯核行列分离</h4><p><code>Kernel=np.zeros([kernelSize],dtype=np.float)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯核行列分离转置</span></span><br><span class="line">KernelRow=Kernel</span><br><span class="line">KernelCol=np.resize(Kernel,(kernelSize,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><strong>高斯核行列分离和两种滤波方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">def SeperateGaussian(imgSrc,imgDst, sigma=1.2):</span><br><span class="line">    timeBegin = cv2.getTickCount()</span><br><span class="line">    # 产生一维高斯滤波器kernel，行列分离</span><br><span class="line">    kernelSize= int(6*sigma-1)//2*2+1</span><br><span class="line">    Kernel=np.zeros([kernelSize],dtype=np.float)</span><br><span class="line"></span><br><span class="line">    pad = kernelSize//2  </span><br><span class="line">    for i in range(kernelSize):</span><br><span class="line">        Kernel[i] = np.exp( -((i-pad) ** 2 ) / (2 * (sigma ** 2)))</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    Kernel /= (2 * np.pi*(sigma**2))</span><br><span class="line">    # 归一化</span><br><span class="line">    Kernel /= Kernel.sum()</span><br><span class="line"></span><br><span class="line">    h,w,channel=imgSrc.shape</span><br><span class="line">    </span><br><span class="line">    # 高斯核行列分离转置</span><br><span class="line">    KernelRow=Kernel</span><br><span class="line">    KernelCol=np.resize(Kernel,(kernelSize,1))</span><br><span class="line">    # # filtering 平滑操作</span><br><span class="line">    </span><br><span class="line">    # 改变参数    </span><br><span class="line">    def filter1():</span><br><span class="line">        # 复制最边缘像素</span><br><span class="line">        transImage = cv2.copyMakeBorder(imgSrc, pad, pad, pad, pad,</span><br><span class="line">                                    borderType=cv2.BORDER_REPLICATE)  </span><br><span class="line">        for x in range(w):</span><br><span class="line">            for k in range(channel): </span><br><span class="line">                temp= np.sum(KernelRow*transImage[ : ,x:x + kernelSize,k], axis=1)</span><br><span class="line">                transImage[:, x+pad, k]=temp</span><br><span class="line"></span><br><span class="line">        for y in range(h):</span><br><span class="line">            for k in range(channel): </span><br><span class="line">                temp= np.sum(KernelCol*transImage[y:y + kernelSize,pad:pad+w,k], axis=0)</span><br><span class="line">                imgDst[y, :, k]=temp</span><br><span class="line"></span><br><span class="line">        cv2.imshow(&#x27;1 Parameter Changed&#x27;,imgDst)</span><br><span class="line">    # 不改变参数       </span><br><span class="line">    def filter2():</span><br><span class="line">        imgDst = np.zeros((h + pad * 2, w + pad * 2, channel), dtype=np.float)</span><br><span class="line">        imgDst[pad: pad + h, pad: pad + w] = imgSrc.copy().astype(np.float)</span><br><span class="line"></span><br><span class="line">        # 创建tmpSrc</span><br><span class="line">        tmpSrc=imgDst.copy()</span><br><span class="line"></span><br><span class="line">        for x in range(w):</span><br><span class="line">            for k in range(channel): </span><br><span class="line">                imgDst[:, x, k]= np.sum(KernelRow*tmpSrc[:,x:x+kernelSize,k], axis=1)</span><br><span class="line">                </span><br><span class="line">        # 更新tmpSrc</span><br><span class="line">        tmpSrc=imgDst.copy()</span><br><span class="line">        for y in range(h):</span><br><span class="line">            for k in range(channel): </span><br><span class="line">                imgDst[y, :, k]= np.sum(KernelCol*tmpSrc[y:y + kernelSize,:,k], axis=0)</span><br><span class="line">                </span><br><span class="line">        # 处理越界像素数据             </span><br><span class="line">        imgDst = np.clip(imgDst, 0, 255)</span><br><span class="line">        imgDst = imgDst[pad: pad + h, pad: pad + w].astype(np.uint8)</span><br><span class="line">        cv2.imshow(&#x27;2 Parameter Unchanged&#x27;,imgDst)</span><br><span class="line"></span><br><span class="line">    filter1()</span><br><span class="line">    # filter2()</span><br><span class="line"></span><br><span class="line">    timeEnd = cv2.getTickCount()</span><br><span class="line">    time = (timeEnd-timeBegin)/cv2.getTickFrequency()</span><br><span class="line">    </span><br><span class="line">    return time</span><br></pre></td></tr></table></figure><p>对于两种滤波方式，显然前一种实现了效果，更新像素时的坐标处理也相对复杂，多一些细节的处理，对x轴和y轴的处理不能通过简单的复制粘贴来实现，而后者可以。<code>num(Kernel*img[:,:,:],axis=0或1)</code>中<code>axis</code>的加入也考察了对python的了解。axis&#x3D;0表示对行（上下）进行操作计算，axis&#x3D;1（左右）表示对列进行操作计算。</p><h3 id="两种算法的性能对比"><a href="#两种算法的性能对比" class="headerlink" title="两种算法的性能对比"></a>两种算法的性能对比</h3><p>未采用行列分离的高斯滤波算法的时间复杂度为$O(N^2)$，分离后，时间复杂度降至$O(N)$。</p><p>当sigma&#x3D;1.2时，</p><p><code>Gaussian()</code>运行用时9.1567s，</p><p><code>SeperateGaussian()</code>运行用时0.1357s；</p><p><code>opencv</code>的函数<code>cv2.GaussianBlur()</code>运行时间仅为0.0062s；</p><p>显然<code>opencv</code>的方法也是使用了行列分离方式，不过其在细节处理上更优秀。</p><p>查阅资料可知，<code>opencv</code>实现的高斯滤波方法为<code>cv2.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]]) → dst</code>，对传入的<code>sigmaX</code>，<code>sigmaY</code>分别产生两个一维卷积核，然后分别再行和列上做卷积，其中<code>sigmaX</code>和<code>sigmaY</code>如果没有传入参数，则由<code>ksize</code>计算得到。</p><p>以上运行时间同样与机器性能有关，不过经过多次测试，在本人机器上的运行时间相对稳定，可以体现不同实现方法在效率上的差距。</p><h3 id="对不同sigma值的测试"><a href="#对不同sigma值的测试" class="headerlink" title="对不同sigma值的测试"></a>对不同sigma值的测试</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>采用行列分离高斯滤波处理方法，测试不同sigma值（标准差）对图片的影响。</p><p>公式<code>[6sigma-1]/2*2+1</code>决定了滤波窗口（核）的大小，sigma值越大，窗口越大，图像也越平滑模糊。</p><p>高斯核的宽度与标准差σ的比值为6倍，为什么？</p><p>因为钟型曲线(高斯函数图像)在区间$(μ−σ,μ+σ)$范围内的面积占曲线下总面积的$68%$，$(μ−2σ,μ+2σ)$范围占$95%$，$(μ−3σ,μ+3σ)$范围占$99.7%$，一般$3σ$外的数值已接近于0，可忽略，半径为$3σ$即窗口大小为$6σ×6σ$即可，通常取最近的奇数。</p><div style="width:40%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Normal_distribution_pdf.png" class></div><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><div style="width:70%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/3-1.jpg" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;margin-bottom:40px;">    原图</div></center><div style="width:70%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/sigma=%E9%9B%B6%E7%82%B9%E5%85%AD.jpg" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;margin-bottom:40px;">    sigma=0.6</div></center><div style="width:70%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/sigma=%E4%B8%80%E7%82%B9%E4%BA%8C.jpg" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;margin-bottom:40px;">    sigma=1.20</div></center>        <div style="width:70%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/sigma=%E4%B8%80%E7%82%B9%E5%85%AB.jpg" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;margin-bottom:40px;">    sigma=1.80</div></center><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://www.cnblogs.com/shine-lee/p/9671253.html">如何确定高斯滤波的标准差和窗口大小 - shine-lee - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://blog.csdn.net/wuqindeyunque/article/details/103694900">opencv高斯滤波GaussianBlur()详解(sigma取值)_wuqindeyunque的博客</a></p></li></ul><ul><li><p><a href="https://blog.csdn.net/m0_43609475/article/details/112447397">（七）滤波与卷积_淡定的炮仗的博客</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43360801/article/details/109488279">OpenCV实验（3）：实现图像的高斯滤波处理_ALTLI的博客-</a></p></li><li><p><a href="https://blog.csdn.net/qq_40464371/article/details/102488727">计算机视觉实验_图像滤波处理_人间不值得_的博客</a></p></li><li><p><a href="https://blog.csdn.net/Ibelievesunshine/article/details/104881204">高斯滤波详解 python实现高斯滤波_Ibelievesunshine的博客</a></p></li><li><p><a href="https://blog.csdn.net/Cowry5/article/details/80188056">Python中np.sum()对axis的个人理解</a></p></li></ul><h2 id="3-2实现图像的联合双边滤波处理"><a href="#3-2实现图像的联合双边滤波处理" class="headerlink" title="3-2实现图像的联合双边滤波处理"></a>3-2实现图像的联合双边滤波处理</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a>实验要求：</h3><p>给定函数：<code>function  im = jbf(D,C,w, sigma_f, sigma_g)</code></p><p>其中：D为输入图像；C为引导图像；W为滤波窗口大小；</p><p><code>sigma_f</code> 为spatial kernel标准差；</p><p><code>sigma_g</code>为range kernel 标准差；</p><p>给定公式：</p><div style="width:100%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/clip_image002-16676326187313.jpg" class="3-1"></div><p>其中：p是q的邻域$Ω$中的一个像素。 f和g是空间和距离内核，通常以高斯的形式表示，$I$是输入图像。</p><ul><li>f 是空间滤波器内核，定义为：<code>exp([-d_f^2]/[2*sigma_f^2])</code></li></ul><p>其中：<code>d_f</code> 为输入图像$I$的像素位置差，<code>sigma_f</code>为空间滤波核函数的标准差</p><ul><li>g是距离滤波器内核，定义为：<code>exp([-d_g^2]/[2*sigma_g^2])</code></li></ul><p>其中：<code>d_g</code>为引导图像$I$ 的像素灰度值差，<code>sigma_g</code>为滤波核函数的标准差</p><p>输入图像*$I$*下采样（1&#x2F;2）得到LR低分辨率图像，再由LR图像上采样2倍得到引导图像。</p><p>注：图像缩放采用双线性插值。</p><p>预期效果</p><div style="width:100%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/clip_image002-16690886598913.png" class="3-1"></div><h3 id="JBF算法说明"><a href="#JBF算法说明" class="headerlink" title="JBF算法说明"></a>JBF算法说明</h3><p>高斯滤波处理图像时，不能很好的保持边缘。**双边滤波(Bilateral Filtering)**在这一点上有改善。双边滤波采用了两个高斯滤波的结合。一个负责计算空间邻近度的权值，也就是常用的高斯滤波器原理。而另一个负责计算像素值相似度的权值。双边滤波是去除图像中的噪声，同时保持细节和边缘清晰度的好方法，可用于电影修复、监控视频修复。</p><p>**联合双边滤波(Joint Bilateral Filtering，JBF)**是双边滤波的扩展，它接受两张图像的输入，其中一张是另一张图片的无闪光灯版本。第二张图像是用闪光灯拍摄的。这两个滤波器之间的唯一区别是，联合双边滤波器使用闪光灯图像的强度差异(difference in intensities)，而不是正常的无闪光灯图像的强度差异。</p><p>摄影的目标是再现照片拍摄环境的丰富性。当环境中光线不足时，照片就会显得与环境不一样，而且很难看到图像的细节，因为它们被弄得很暗。闪光灯摄影解决了这个问题，它为环境中的附近物体增加了人工光线，这样相机就可以使用较短的曝光时间和较小的光圈宽度来捕捉足够的光线，产生闪光灯图像。这些图像的光照度更高，其清晰度也得到了提高，并消除了噪音。然而，闪光灯照片有一些缺点，如相机附近物体的亮度不相称，以及人们的红眼。联合双边滤波器利用无闪光灯和闪光灯图像的优点，产生一个清晰的无噪声的无闪光灯图像。$gr(Fp-Fp’)$占去了噪声，因为在闪光灯图像中没有噪声，乘以无闪光灯图像邻居的强度后，无闪光灯图像被重新创建，细节更多，噪声更少。<br>        联合双边滤波器有很多应用，因为它是一个非常有效的滤波器。一个例子是<strong>去除图像中的雾气</strong>–该滤波器将去除图像中的大部分雾气，这样就更容易看到周围的环境。这样做的原因是闪光灯下的图像透过雾气有更高的可见度。另一个例子是<strong>医疗成像中的相机</strong>，它可以用来锐化图像的质量，以便更清楚地看到器官或内部细胞结构，从而得出准确的诊断。这是因为过滤器在使用有效的参数时，可以去除图像中的噪音，并使更精细的细节更加清晰。最后一个例子是在可见光或红外线过滤中。</p><p>以上说明来自某篇[报告](<a href="https://github.com/FaiZaman/Joint-Bilateral-Filter">FaiZaman&#x2F;Joint-Bilateral-Filter: An implementation and description of the joint bilateral filter in Python 3. (github.com)</a>)，用于学习JBF的理论知识和补充文章内容。</p><p>此外，实验说明中关于sigma_f和sigma_g的说明没有太理解，找了知乎上的一篇文章用于了解。</p><p>来自<a href="https://zhuanlan.zhihu.com/p/161665205">双边滤波原理(Bilateral Filtering)</a></p><blockquote><p>对于参数的选取，进行如下讨论：</p><p>首先，两个 sigma 值为 kernel 的方差，方差越大，说明权重差别越小，因此表示不强调这一因素的影响，反之，则表示更强调这一因素导致的权重的不均衡。因此：</p><p>两个方面的某个的 sigma 相对变小 表示这一方面相对较重要，得到强调。如 sigma_d 变小，表示更多采用近邻的值作平滑，说明图像的空间信息更重要，即相近相似。如 sigma_r 变小，表示和自己同一类的条件变得苛刻，从而强调值域的相似性。</p><p>其次，sigma_d 表示的是空域的平滑，因此对于没有边缘的，变化慢的部分更适合；sigma_r 表示值域的差别，因此强调这一差别，即减小 sigma_r 可以突出边缘。</p><p>sigma_d 变大，图像每个区域的权重基本都源于值域滤波的权重，因此对于空间邻域信息不是很敏感；sigma_r 变大，则不太考虑值域，权重多来自于空间距离，因此近似于普通的高斯滤波，图像的保边性能下降。因此如果像更多的去除平滑区域的噪声，应该提高 sigma_d ，如果像保持边缘，则应该减小 sigma_r 。</p><p>极端情况，如果 sigma_d 无穷大，相当于值域滤波；sigma_r 无穷大，相当于空域高斯滤波。</p></blockquote><p>最后，公式中的$||x||$表示向量的范数，</p><p>举例：</p><p>If  $x &#x3D; (x1, x2, x3)$  then $||x|| &#x3D; (x1^2 + x2^2 + x3^2)^{0.5}$</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要来自<a href="https://github.com/laurencebho/iproc">laurencebho&#x2F;iproc: Bilateral filter &amp; joint bilateral filter (github.com)</a>，就不再重复贴了，主要逻辑比较清晰，不过注释较少。更易懂的代码实现方式可以看这篇文章–<a href="https://blog.csdn.net/weixin_43360801/article/details/109488537">实现图像的联合双边滤波处理_ALTLI的博客</a>，其运行速度优化得也更好。</p><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/FaiZaman/Joint-Bilateral-Filter">FaiZaman&#x2F;Joint-Bilateral-Filter: An implementation and description of the joint bilateral filter in Python 3. (github.com)</a></li><li><a href="https://github.com/laurencebho/iproc">laurencebho&#x2F;iproc: Bilateral filter &amp; joint bilateral filter (github.com)</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/127023952">OpenCV 学习：９ 双边滤波bilateralFilter</a></li></ul><ul><li><p><a href="https://zhuanlan.zhihu.com/p/161665205">双边滤波原理（Bilateral Filtering）</a></p></li><li><p><a href="https://blog.csdn.net/qq_36359022/article/details/80198890">OpenCV双边滤波详解及实代码实现_青城山小和尚的博客</a></p></li><li><p><a href="https://blog.csdn.net/panda1234lee/article/details/52839205">联合双边滤波器（joint bilateral filter)</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43360801/article/details/109488537">OpenCV实验（4）：实现图像的联合双边滤波处理_ALTLI的博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV之人脸面部识别</title>
      <link href="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%94%E3%80%81OpenCV%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%94%E3%80%81OpenCV%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>实验4–人脸面部识别</p><p>基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。</p><span id="more"></span><h2 id="实验4-人脸面部识别"><a href="#实验4-人脸面部识别" class="headerlink" title="实验4 人脸面部识别"></a><strong>实验4 人脸面部识别</strong></h2><p><strong>简介：</strong>人脸面部识别技术</p><p>基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。</p><p>下面的实验内容是简单识别出图像中人物的面部，进而为以后更深层次的学习打下基础。</p><p><strong>实验要求</strong>：</p><p>1）介绍人脸识别技术的基本实现原理；</p><p>2）人脸识别程序流程图设计；</p><p>3）根据提供的图像或自己选用图像，编写程序，能够识别出图像中人物的脸部；<strong>识别时用的人脸特征：</strong>“三庭五眼 ”规则高度和宽度比例应该在（ 0.6, 2）内+眼部特征。</p><p>4）实验结果展示。</p><div style="width:80%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%94%E3%80%81OpenCV%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221208204809367.png" class></div><h2 id="一、人脸检测技术原理"><a href="#一、人脸检测技术原理" class="headerlink" title="一、人脸检测技术原理"></a>一、人脸检测技术原理</h2><h4 id="1、原理总说"><a href="#1、原理总说" class="headerlink" title="1、原理总说"></a>1、原理总说</h4><ul><li><p>在检测到人脸并定位面部关键特征点之后，主要的人脸区域就可以被裁剪出来，经过预处理之后，馈入后端的识别算法。识别算法要完成人脸特征的提取，并与库存的已知人脸进行比对，完成最终的分类。</p></li><li><p>本实验要做的就是人脸识别工作的第一步：人脸检测与框定。</p></li><li><p>主要利用的人脸特征是肤色、高宽比（“三庭五眼 ”规则高度和宽度比例应该在（0.6, 2）内 ）和眼部特征。</p></li><li><p>基于肤色的人脸分割主要分为三大部分：</p><p>  （1）预处理，针对噪声，光照带来的影响进行消除。</p><p>  （2）基于肤色模型的肤色分割。</p><p>  （3）连通域分析，人脸区域定位。</p></li></ul><h4 id="2、基于肤色高斯模型实现人脸区域分割提取的原理"><a href="#2、基于肤色高斯模型实现人脸区域分割提取的原理" class="headerlink" title="2、基于肤色高斯模型实现人脸区域分割提取的原理"></a>2、基于肤色高斯模型实现人脸区域分割提取的原理</h4><ul><li>通过比较<code>RGB</code>，<code>HSV</code>，<code>Ycbc</code>r空间，发现<code>Ycbcr</code>和<code>HSV</code>空间在进行人脸肤色分割方面由于肤色范围紧密，不易受光照其他物体干扰（基于肤色模型的，如果背景中有与人脸颜色类似的物体，且距离较近很容易产生干扰，影响人脸区域定位的准确性，这也是这一算法不能解决的问题）。但是<code>RGB</code>与<code>HSV</code>空间的转换相比<code>RGB</code>到<code>Ycbcr</code>空间转换来说较为复杂些，所以我们采用<code>Ycbcr</code>空间进行人脸肤色的建模与分割。</li></ul><h4 id="3、根据人脸特征筛选"><a href="#3、根据人脸特征筛选" class="headerlink" title="3、根据人脸特征筛选"></a>3、根据人脸特征筛选</h4><ul><li>人脸区域定位，使用连通区域分析，获取二值图像最小外接矩形，即为人脸区域。 采用的是八邻域连通。</li><li>高宽比（“三庭五眼 ”规则高度和宽度比例应该在（ 0.6, 2）内）不符合要求的去掉</li><li>符合要求的区域也可能是胳膊，服饰之类的。我们在这个区域内找眼睛。在肤色的二值图像里，眼珠位置一般是深色，所以我们将这个区域图像取反，再进行连通区域分析，按眼睛与脸的外接矩形尺寸比例筛选得到眼睛。如果在这个区域里能找到一个以上眼睛，判定这个区域是脸。</li><li>将脸区域框起来。</li></ul><p>详细的内容再抄就不礼貌了，还是看这个吧：<a href="https://blog.csdn.net/qq_41748260/article/details/103992272">计算机视觉实验四 人脸面部识别_小西几y的博客-CSDN博客_实验四 人脸识别</a></p><h2 id="二、流程图"><a href="#二、流程图" class="headerlink" title="二、流程图"></a>二、流程图</h2><div style="width:80%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%94%E3%80%81OpenCV%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" class></div><p>三、实验代码及效果</p><p>代码不再重复粘贴（多少有点心虚</p><p>实现效果展示如下：</p><div style="width:80%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%94%E3%80%81OpenCV%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221212203310841.png" class></div><div style="width:80%;margin:auto;"><img src="/2022/12/12/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%94%E3%80%81OpenCV%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221212203323053.png" class></div><p>可见程序的确成功识别人脸，但是在标定眼睛时，出现了标注不全和标注错误的情况，这是一个可以优化的点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/36621308">人脸检测算法综述 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/qq_41748260/article/details/103992272">计算机视觉实验四 人脸面部识别_小西几y的博客</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43360801/article/details/109800935">OpenCV实验（7）：人脸面部识别_ALTLI的博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV之几何变换和变形</title>
      <link href="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>实验2–图像的几何变换和变形</p><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/rightTwist.png" class></div><span id="more"></span><h2 id="OpenCV学习记录（三）"><a href="#OpenCV学习记录（三）" class="headerlink" title="OpenCV学习记录（三）"></a>OpenCV学习记录（三）</h2><h2 id="几何变换和变形"><a href="#几何变换和变形" class="headerlink" title="几何变换和变形"></a>几何变换和变形</h2><h2 id="图像缩放"><a href="#图像缩放" class="headerlink" title="图像缩放"></a>图像缩放</h2><blockquote><p>实验要求：1）实现一个图像缩放函数，可以对输入图像进行任意倍数的缩放；</p><p>2）采用双线性插值进行重采样；</p><p>3）X,Y方向的缩放倍数参函数参数的形式传入；</p><p>4）可以只考虑输入图像为3通道，8位深度的情况；</p><p>5）不能调用图像处理库的缩放函数来完成；</p></blockquote><h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p><a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC&action=edit&section=1">双线性插值（摘自维基百科）</a></p><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Bilinear_interpolation.png" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    红色的数据点与待插值得到的绿色点</div></center><p>假如我们想得到未知函数 <em>f</em> 在点${\displaystyle P&#x3D;\left(x,y\right)}$的值，假设我们已知函数 <em>f</em> 在 ${\displaystyle Q_{11}&#x3D;\left(x_{1},y_{1}\right)}$ ， ${\displaystyle Q_{12}&#x3D;\left(x_{1},y_{2}\right)}$ ，${\displaystyle Q_{21}&#x3D;\left(x_{2},y_{1}\right)}$，${\displaystyle Q_{22}&#x3D;\left(x_{2},y_{2}\right)}$   四个点的值，首先在<em>x</em>方向进行线性插值，得到<br>$$<br>{\displaystyle {\begin{aligned}f(x,y_{1})&amp;\approx {\frac {x_{2}-x}{x_{2}-x_{1}}}f(Q_{11})+{\frac {x-x_{1}}{x_{2}-x_{1}}}f(Q_{21}),<br>\\f(x,y_{2})&amp;\approx {\frac {x_{2}-x}{x_{2}-x_{1}}}f(Q_{12})+{\frac {x-x_{1}}{x_{2}-x_{1}}}f(Q_{22}).\end{aligned}}}<br>$$</p><p>然后在 <em>y</em> 方向进行线性插值，得到<br>$$<br>{\displaystyle {\begin{aligned}f(x,y)&amp;\approx {\frac {y_{2}-y}{y_{2}-y_{1}}}f(x,y_{1})+{\frac {y-y_{1}}{y_{2}-y_{1}}}f(x,y_{2})<br>\\&amp;&#x3D;{\frac {y_{2}-y}{y_{2}-y_{1}}}\left({\frac {x_{2}-x}{x_{2}-x_{1}}}f(Q_{11})+{\frac {x-x_{1}}{x_{2}-x_{1}}}f(Q_{21})\right)+{\frac {y-y_{1}}{y_{2}-y_{1}}}\left({\frac {x_{2}-x}{x_{2}-x_{1}}}f(Q_{12})+{\frac {x-x_{1}}{x_{2}-x_{1}}}f(Q_{22})\right)<br>\\&amp;&#x3D;{\frac {1}{(x_{2}-x_{1})(y_{2}-y_{1})}}{\big (}f(Q_{11})(x_{2}-x)(y_{2}-y)+f(Q_{21})(x-x_{1})(y_{2}-y)+f(Q_{12})(x_{2}-x)(y-y_{1})+f(Q_{22})(x-x_{1})(y-y_{1}){\big )}<br>\\&amp;&#x3D;{\frac {1}{(x_{2}-x_{1})(y_{2}-y_{1})}}{\begin{bmatrix}x_{2}-x&amp;x-x_{1}\end{bmatrix}}{\begin{bmatrix}f(Q_{11})&amp;f(Q_{12})\\f(Q_{21})&amp;f(Q_{22})\end{bmatrix}}{\begin{bmatrix}y_{2}-y\\y-y_{1}\end{bmatrix}}.\end{aligned}}}<br>$$<br>注意此处如果先在 <em>y</em> 方向插值、再在 <em>x</em> 方向插值，其结果与按照上述顺序双线性插值的结果是一样的。</p><h3 id="双线性内插值算法核心"><a href="#双线性内插值算法核心" class="headerlink" title="双线性内插值算法核心"></a><a href="https://blog.csdn.net/pentiumCM/article/details/104720100">双线性内插值算法核心</a></h3><p>对于一个目的像素点$dst[x][y]$，通过反向变换得到的源图像中 浮点坐标为 $src[i + u][j + v]$ (其中i、j均为浮点坐标的整数部分，u、v为浮点坐标的小数部分，是取值[0,1)区间的浮点数)，则这个像素点的值$ f(i+u,j+v) $可由原图像中坐标为$ (i,j)、(i+1,j)、(i,j+1)、(i+1,j+1)$所对应的最相邻四个像素点的值（ 灰度值或者RGB值）决定，即：<br>$$<br>f(i+u,j+v) &#x3D; (1-u)(1-v)f(i,j) + (1-u)vf(i,j+1) + u(1-v)f(i+1,j) + uvf(i+1,j+1)<br>$$<br>其中$f(i,j)$表示源图像$(i,j)$处的的值（灰度值或者RGB值），以此类推。</p><p>实现代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">双线性插值法对图像进行缩放</span></span><br><span class="line"><span class="string">:file :原图路径</span></span><br><span class="line"><span class="string">:h    :高度缩放倍数（是原图的h倍）</span></span><br><span class="line"><span class="string">:w    :宽度缩放倍数（是原图的w倍）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resizeImg</span>(<span class="params">file,h,w</span>):</span><br><span class="line">    timeBegin = cv2.getTickCount()  <span class="comment"># 记录开始时间</span></span><br><span class="line">    src_img=cv2.imread(file)</span><br><span class="line">    <span class="comment"># cv2.imshow(&#x27;src_img&#x27;,src_img)</span></span><br><span class="line">    <span class="comment"># 获取图片的参数，高，宽，通道数</span></span><br><span class="line">    <span class="comment"># print(im.shape)</span></span><br><span class="line">    src_h,src_w,channel=src_img.shape</span><br><span class="line">    <span class="comment"># 计算新图的尺寸,四舍五入为整数</span></span><br><span class="line">    dst_h=<span class="built_in">round</span>(src_h*h)</span><br><span class="line">    dst_w=<span class="built_in">round</span>(src_w*w)</span><br><span class="line">    dst_img=np.zeros((dst_h,dst_w,<span class="number">3</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#转换为src/dst 的尺寸比</span></span><br><span class="line">    scale_w=<span class="built_in">float</span>(<span class="number">1.0</span>/w)</span><br><span class="line">    scale_h=<span class="built_in">float</span>(<span class="number">1.0</span>/h)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dst_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dst_w):</span><br><span class="line">            srcX = <span class="built_in">float</span>((j + <span class="number">0.5</span>) * scale_w - <span class="number">0.5</span>)</span><br><span class="line">            srcY = <span class="built_in">float</span>((i + <span class="number">0.5</span>) * scale_h - <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 向下取整，代表靠近源点的左上角的那一点的行列号</span></span><br><span class="line">            srcX_int=math.floor(srcX)</span><br><span class="line">            srcY_int=math.floor(srcY)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 取出小数部分，用于构造权值</span></span><br><span class="line">            srcX_float = srcX - srcX_int</span><br><span class="line">            srcY_float = srcY - srcY_int</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> srcX_int + <span class="number">1</span> == src_w <span class="keyword">or</span> srcY_int + <span class="number">1</span> == src_h:</span><br><span class="line">                dst_img[i, j, :] = src_img[srcY_int, srcX_int, :]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dst_img[i, j, :] = (<span class="number">1.0</span> - srcY_float) * (<span class="number">1.0</span> - srcX_float) * src_img[srcY_int, srcX_int, :] + \</span><br><span class="line">                               (<span class="number">1.0</span> - srcY_float) * srcX_float * src_img[srcY_int, srcX_int + <span class="number">1</span>, :] + \</span><br><span class="line">                               srcY_float * (<span class="number">1.0</span> - srcX_float) * src_img[srcY_int + <span class="number">1</span>, srcX_int, :] + \</span><br><span class="line">                               srcY_float * srcX_float * src_img[srcY_int + <span class="number">1</span>, srcX_int + <span class="number">1</span>, :]</span><br><span class="line"></span><br><span class="line">    msg=<span class="string">&#x27;scale_h:&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">round</span>(scale_h,<span class="number">2</span>))+<span class="string">&#x27;, scale_w:&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">round</span>(scale_w,<span class="number">2</span>))</span><br><span class="line">    cv2.namedWindow(msg,cv2.WINDOW_NORMAL)</span><br><span class="line">    cv2.imshow(msg,dst_img)</span><br><span class="line">    timeEnd = cv2.getTickCount()  </span><br><span class="line">    time=(timeEnd-timeBegin)/ cv2.getTickFrequency()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;运行时间%.4f&#x27;</span>,time)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>原图：</p><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/lab2.png" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    原图</div></center><p>按h倍高，w倍比例缩放</p><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/h=1.5,w=0.7.png" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    h=1.5，w=0.7</div></center><h2 id="图像变形"><a href="#图像变形" class="headerlink" title="图像变形"></a>图像变形</h2><p><strong>实验要求：</strong></p><blockquote><p>记$[x′,y′]&#x3D;f([x,y])$为像素坐标的一个映射，实现$f$所表示的图像形变。$f$的逆映射为：</p><p>$$<br>\begin{equation}<br>[x,y]&#x3D;f^{-1}([x,y])&#x3D;\begin{cases}<br>[x’,y’],&amp;\text{if r&gt;1 }  \\<br>\cos ( \theta )x’- \sin ( \theta )v’, \sin ( \theta )x’+ \cos ( \theta )v’]&amp;\text{otherwise}<br>\end{cases}<br>\end{equation}<br>$$<br>其中：<br>$$<br>\begin{align*}<br>r&#x3D;\sqrt {x’^2+y’^2}&amp;&amp;θ&#x3D;(1-r)^2\<br>\end{align*}<br>$$</p><p>$[x,y],[x′,y′]$都是中心归一化坐标，请先进行转换；</p><p>中心归一化坐标：</p><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Bilinear_interpolation.png" class></div><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/xxx.png" class></div></blockquote><p>解法：基本是先按照实验说明处理坐标数据，仿照示例的matlab代码也能做出，原理就不再赘述了（大雾）。</p><p>24行到29行是两种不同的缩放方向，x应该对应图像的宽，y对应图像的高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twistImg</span>(<span class="params">file</span>):</span><br><span class="line">    timeBegin = cv2.getTickCount()  <span class="comment"># 记录开始时间</span></span><br><span class="line">    src_img=cv2.imread(file)</span><br><span class="line">    <span class="comment"># cv2.imshow(&#x27;src_img&#x27;,src_img)</span></span><br><span class="line">    <span class="comment"># 获取图片的参数，高，宽，通道数</span></span><br><span class="line">    <span class="comment"># print(im.shape)</span></span><br><span class="line">    src_h,src_w,channel=src_img.shape</span><br><span class="line">    dst_img=np.zeros((src_h,src_w,<span class="number">3</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中心归一化坐标</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(src_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(src_w):</span><br><span class="line">            tempx = (j-<span class="number">0.5</span>*src_w)/(<span class="number">0.5</span>*src_w)</span><br><span class="line">            tempy = (i-<span class="number">0.5</span>*src_h)/(<span class="number">0.5</span>*src_h)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取r和angle</span></span><br><span class="line">            r=math.sqrt(tempx**<span class="number">2</span>+tempy**<span class="number">2</span>)</span><br><span class="line">            K=(<span class="number">1</span>-r)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r&gt;=<span class="number">1</span>):</span><br><span class="line">                x=tempx</span><br><span class="line">                y=tempy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左旋</span></span><br><span class="line">                x = math.cos(K)*tempx - math.sin(K)*tempy</span><br><span class="line">                y = math.sin(K)*tempx + math.cos(K)*tempy</span><br><span class="line">                <span class="comment"># 右旋</span></span><br><span class="line">                y = math.cos(K)*tempy - math.sin(K)*tempx</span><br><span class="line">                x = math.sin(K)*tempy + math.cos(K)*tempx</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理坐标，避免索引出错</span></span><br><span class="line">            x=(x+<span class="number">1</span>)*<span class="number">0.5</span>*src_w</span><br><span class="line">            y=(y+<span class="number">1</span>)*<span class="number">0.5</span>*src_h</span><br><span class="line">            <span class="comment"># 使用math.floor()函数将坐标转为整数</span></span><br><span class="line">            dst_img[i,j,:]=src_img[math.floor(y),math.floor(x),:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    msg=<span class="string">&#x27;twistImg&#x27;</span></span><br><span class="line">    cv2.namedWindow(msg,cv2.WINDOW_NORMAL)</span><br><span class="line">    cv2.imshow(msg,dst_img)</span><br><span class="line">    timeEnd = cv2.getTickCount()  </span><br><span class="line">    time=(timeEnd-timeBegin)/ cv2.getTickFrequency()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;运行时间%.4f&#x27;</span>,time)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>32行对坐标的处理</p><p>最初我们按公式 ${x&#x3D;{\frac {x-0.5w}{0.5w}}}$将坐标中心归一化了，完成形变后需要还原，也就是$x&#x3D;(x+1)<em>0.5</em>w$，若不如此做，得到的结果如下，具体原理不太清楚。</p><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/colorTwist.png" class></div><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/lesfTwist.png" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    左旋</div></center><div style="width:40%;margin:auto;"><img src="/2022/10/31/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81OpenCV%E4%B9%8B%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E5%92%8C%E5%8F%98%E5%BD%A2/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/rightTwist.png" class></div><center> <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    右旋</div></center><p>ps：这是一篇缺乏理论的文章，花了不少时间来打公式而非探究原理。没给示例的话，自己写还有些困难。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/pentiumCM/article/details/104720100"> CV — 双线性插值算法（csdn）</a></p><p><a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC&action=edit&section=1">双线性插值（维基百科）</a></p><p><a href="https://zhuanlan.zhihu.com/p/110754637">一篇文章为你讲透双线性插值 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV之图像合成</title>
      <link href="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>实验1-2，用alpha混合，为图片替换一张新的背景</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/out.png" class></div><span id="more"></span><h2 id="OpenCV学习记录（二）"><a href="#OpenCV学习记录（二）" class="headerlink" title="OpenCV学习记录（二）"></a>OpenCV学习记录（二）</h2><h2 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h2><blockquote><p>实验1-2：图像合成</p><p>实验要求：</p><p>1）现有一张4通道透明图像a.png:</p><p>2）从其中提取出alpha通道并显示;</p><p>3）用alpha混合，为a.png替换一张新的背景（bg.png）。 </p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221027221157348.png" class></div></blockquote><h2 id="图像通道"><a href="#图像通道" class="headerlink" title="图像通道"></a>图像通道</h2><p><strong>首先，先了解什么是图像通道。</strong></p><p>一幅完整的图像，红色绿色蓝色三个通道缺一不可。即使图像中看起来没有蓝色，只能说蓝色光的亮度均为0或者各像素值的红色和绿色通道不全为0，但不能说没有蓝色通道存在。</p><p>一张RGB图像含有三个通道：红（<strong>R</strong>ed）、绿（<strong>G</strong>reen）、蓝（<strong>B</strong>lue）。一张RGBA图像含有四个通道：红（<strong>R</strong>ed）、绿（<strong>G</strong>reen）、蓝（<strong>B</strong>lue）和Alpha（<strong>A</strong>）。一张灰度图则只有一个通道。</p><p>至于实验中提到的Alpha通道（α Channel），是计算机图形学中的术语，指的是特别的通道，意思是“非彩色”通道，主要是用来保存选区和编辑选区，代表透明度。至于为什么用<code>α</code>来表示，可能是因为它是不表示某种颜色的图片的第一个属性，毕竟α自身没有所谓”透明度“的含义。</p><h2 id="提取通道"><a href="#提取通道" class="headerlink" title="提取通道"></a>提取通道</h2><p>那么，如何确定一张图片拥有的通道数，又怎样将不同通道的图像分别提取出来呢？</p><p>下面是提取通道的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#OpenCV的方式</span></span><br><span class="line"><span class="comment">#读入完整图片，包括alpha通道</span></span><br><span class="line">im=cv2.imread(file,cv2.IMREAD_UNCHANGED)</span><br><span class="line"><span class="comment">#输出图片信息（宽，长，通道数），RGBA通道数为4</span></span><br><span class="line"><span class="built_in">print</span>(im.shape)</span><br><span class="line"><span class="comment">#分别接受图片的四个通道，a代表alpha</span></span><br><span class="line"><span class="comment">#下面三种方式效果都是一样的</span></span><br><span class="line">b,g,r,a=cv2.split(im)</span><br><span class="line"><span class="comment">#3表示第4个通道，也可以用-1，表示倒数第一个</span></span><br><span class="line">a=cv2.split(im)[<span class="number">3</span>]</span><br><span class="line">a=im[:,:,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#PIL的方式</span></span><br><span class="line">im=Image.<span class="built_in">open</span>(file)</span><br><span class="line">r,g,b,a=im.split()</span><br><span class="line"><span class="comment">#用-1表示倒数第一个通道</span></span><br><span class="line">a=im.split()[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="四通道图片"><a href="#四通道图片" class="headerlink" title="四通道图片"></a>四通道图片</h2><p>原图</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/a.png" class></div><p>r通道</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/r_a.png" class></div><p>g通道</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/g_a.png" class></div><p>b通道</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/b_a.png" class></div><p>α通道</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/alpha3.png" class></div><h2 id="图片合成"><a href="#图片合成" class="headerlink" title="图片合成"></a>图片合成</h2><blockquote><p>用alpha混合，为a.png替换一张新的背景（bg.png）</p></blockquote><p>起初，筛选用关键字”图像合成“搜索到的教程，我选择用python的PIL库的<code>Image.blend(im1,im2,0.5)</code>方法。</p><p><code>im1</code>和<code>im2</code>是两张模式（mode，如rgb）、大小（size）和通道数都相同的图片，如果不同则需要预处理。第三个参数则是<code>im1</code>的透明度，取值范围为[0,1]。</p><p>根据公式</p><p><code>blend_img = img1 * (1 – alpha) + img2 * alpha</code></p><p>调整alpha的值，产生的图片又不同的效果。</p><p>运行下面的代码，alpha是提取的alpha通道图，im2是背景图。</p><p><code>out=Image.blend(alpha,im2,0.5)</code></p><p>可是得到的结果却不是想象中的那样……</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%A4%B1%E8%B4%A5.png" class></div><p>可以发现上图只是两张图片整体的简单重叠，中间的玩偶甚至只有轮廓。而把<code>alpha</code>换成<code>im1</code>，得到的效果是：</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%A4%B1%E8%B4%A52.png" class></div><p>有一点雏形，调节参数也无济于事。但可以发现，blend函数应该并不是解决此问题的钥匙，alpha本应该是提取出的图像、矩阵，而非一个介于0到1的数字。</p><p>在opencv中的等效方法是<a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19">cv.addWeighted()</a>，也就是改变图像权重。</p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221029153952470.png" class></div><p>上图来自课件，介绍的是图像的加法和乘法，看上去不难理解，但是具体应该怎么操作呢？</p><p>搜索关键字，<code>alpha blending</code>，算是找到了救星。</p><p>在这篇文章<a href="https://learnopencv.com/alpha-blending-using-opencv-cpp-python/#disqus_thread">Alpha Blending using OpenCV (C++ &#x2F; Python)</a>中，作者较为详细的说明了alpha混合的相关知识（其实和我之前了解到的不差），<strong>并给出了实例代码</strong>，这才让我徒劳的搜索工作到了尽头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"> </span><br><span class="line"># Read the images</span><br><span class="line">foreground = cv2.imread(&quot;puppets.png&quot;)</span><br><span class="line">background = cv2.imread(&quot;ocean.png&quot;)</span><br><span class="line">alpha = cv2.imread(&quot;puppets_alpha.png&quot;)</span><br><span class="line"> </span><br><span class="line"># Convert uint8 to float</span><br><span class="line">foreground = foreground.astype(float)</span><br><span class="line">background = background.astype(float)</span><br><span class="line"> </span><br><span class="line"># Normalize the alpha mask to keep intensity between 0 and 1</span><br><span class="line">alpha = alpha.astype(float)/255</span><br><span class="line"> </span><br><span class="line"># Multiply the foreground with the alpha matte</span><br><span class="line">foreground = cv2.multiply(alpha, foreground)</span><br><span class="line"> </span><br><span class="line"># Multiply the background with ( 1 - alpha )</span><br><span class="line">background = cv2.multiply(1.0 - alpha, background)</span><br><span class="line"> </span><br><span class="line"># Add the masked foreground and background.</span><br><span class="line">outImage = cv2.add(foreground, background)</span><br><span class="line"> </span><br><span class="line"># Display image</span><br><span class="line">cv2.imshow(&quot;outImg&quot;, outImage/255)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure><p>对上面代码做出“本土化修改”，调节图片格式和通道（都转为3通道图像），最终得出了下面结果。</p><p><strong>OHHHHHHHH!</strong></p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E7%BB%93%E6%9E%9C.png" class></div><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>按照给定的代码运行的结果符合预期，下面分析一下这些代码具体做了什么（虽然本来就有注释）。</p><p>读入的三张图片预先做了处理使之格式一致，然后代码</p><p><code>foreground = foreground.astype(float)</code></p><p>将图像数据类型从<code>unit8</code> 转成了<code>float</code>。</p><p><strong>为什么要做这样的处理？</strong></p><p>先看一段找到的Matlab的相关说明</p><p>为了节省存储空间，matlab为图像提供了特殊的数据类型uint8(8位无符号整数），以此方式存储的图像称作8位图像。matlab读入图像的数据是uint8，而matlab中数值一般采用double型（64位）运算。<br>        运算的时候将原图像的灰度值转换成double的作用主要是考虑计算过程中的精度的问题，double的数据是有小数点的，而uint8是0－255的整数，如果直接用uint8计算，会在计算过程中产生舍入误差，这种误差在图像的数据中是比较大的误差。</p><p><strong>python中同理</strong>。</p><p>python中展示图像时，图片数据类型应该是unit8，运算时，采用float或者np.double（将代码中的float替换为np.double效果一致）。</p><p>再看看两次乘法和一次加法操作的结果吧。</p><p><strong>主体*Alpha</strong></p><p><code>foreground = cv.multiply(alpha, foreground)</code></p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/foreground.png" class></div><p><strong>背景*(1-Alpha)</strong></p><p><code>background = cv.multiply(1 - alpha, background)</code></p><div style="width:40%;margin:auto;"><img src="/2022/10/29/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/background.png" class></div><p><strong>主体+背景</strong></p><p><code>outImage = cv.add(foreground, background)</code></p><p>就是前面的合成图片啦。</p><p>代码的逻辑，正应用了前面提过的公式</p><p>lmage Composite (合成):C&#x3D;αF+(1-α)B</p><p>到此，实验一才算做完了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E9%80%9A%E9%81%93/5153230">图像通道_百度百科 </a></li><li><a href="https://blog.csdn.net/mvtechnology/article/details/9008499">图像的通道数（channels）解释_</a></li><li><a href="https://www.cnblogs.com/suogasus/p/5311264.html">什么是Alpha通道？</a></li><li><a href="https://blog.csdn.net/qq_38765642/article/details/110311100">cv.imread（）函数</a></li><li><a href="https://blog.csdn.net/AugustMe/article/details/112370003">PIL.Image.blend()的使用</a></li><li><a href="https://learnopencv.com/alpha-blending-using-opencv-cpp-python/#disqus_thread">Alpha Blending using OpenCV (C++ &#x2F; Python)</a></li><li><a href="https://blog.csdn.net/LaoYuanPython/article/details/109105916">[Python+OpenCV（四）——像素运算]</a></li><li><a href="https://blog.csdn.net/LaoYuanPython/article/details/109105916">OpenCV-Python图像乘法运算cv2.multiply函数详解及像素值溢出归一化处理</a></li><li><a href="https://blog.csdn.net/banxia1995/article/details/87924224">python中图片的float类型和uint8类型</a></li><li><a href="https://blog.csdn.net/Dujing2019/article/details/89042609">matlab图像数据类型uint8,double关系</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV之图像显示</title>
      <link href="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>记录OpenCV入门经历以及数字图像处理课程的实验</p><span id="more"></span><h2 id="OpenCV学习记录（一）"><a href="#OpenCV学习记录（一）" class="headerlink" title="OpenCV学习记录（一）"></a>OpenCV学习记录（一）</h2><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>使用Python搭配VS-Code和OpenCV库进行实验环境的配置。</p><p>由于python环境和VS-Code很早就安装配置好了，此部分只谈如何在前两者的基础上配置OpenCV的实验环境。</p><p>相比于C++&amp;VS-Code&amp;OpenCV 环境的配置，我要做的其实很简单。</p><p>在命令行窗口（cmd）中输入<code>pip install opencv-python</code>，环境就配置完成了。</p><p>新建一个文件夹作为项目地址，用VSCode将其打开，然后新建一个文件，如<code>ex.py</code>，写入代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">&#x27;eg.jpg&#x27;</span>,cv2.IMREAD_UNCHANGED)</span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;girl&#x27;</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;girl&#x27;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>eg.jpg</code>是py文件同级文件夹下的一张图片，如果图片位置在其他地方，则可以通过相对路径或者绝对路径来访问。</p><p>然后运行即可，运行效果如下：</p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221027204812288.png" alt="image-20221027204812288.png"></p><p> 绝对路径较为简单，但若路径较长会使观感不太好。若使用相对路径，可能还需要简单的配置。</p><h2 id="VS-Code设置"><a href="#VS-Code设置" class="headerlink" title="VS-Code设置"></a>VS-Code设置</h2><p>说到相对路径，VS-Code有一个较为奇怪的设置。</p><p>即运行<code>print(os.getcwd())</code>这行代码时，程序在VS-Code中运行的输出和直接运行后在cmd中的输出结果不一致。如，若该文件的实际位置是<code>D:\Course\DigImgProcessing\exp1\exp.py</code>，则前者输出是<code>D:\Course\DigImgProcessing</code>，后者输出是<code>D:\Course\DigImgProcessing\exp1</code>。</p><p>原因：VS Code把用“File”菜单-&gt;”Open Folder…”选项打开的文件夹的位置(${workspaceFolder} )当做<strong>默认当前工作路径</strong>。</p><p><strong>解决方案：</strong></p><p>先在Settings中，<strong>勾选“Terminal：Excute In File Dir”</strong>，</p><p>然后在项目配置文件<code>launch.json</code>中添加<code>&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</code>即可。</p><h2 id="从实验讲起"><a href="#从实验讲起" class="headerlink" title="从实验讲起"></a>从实验讲起</h2><p>终于谈到了学习OpenCV的原因，其实就是数字图像处理实验需要我学习和使用它。</p><p>我是怎么摸索并知道要用它来做实验？其实很简单，无非是老一套的搜索原题找到教程罢了，这一点就不再赘述，先看看第一次实验的题目吧！</p><blockquote><p>Pset1_Basic Image Manipulation</p><p>实验1-1：图像显示</p><p>实验要求：</p><p>1）利用图像库的功能，实现从文件加载图像，并在窗口中进行显示的功能；</p><p>2）利用常见的图像文件格式（.jpg； .png； .bmp； .gif）进行测试。</p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/clip_image002.jpg" alt="img"></p><p>实验1-2：图像合成</p><p>实验要求：</p><p>1）现有一张4通道透明图像a.png:</p><p>2）从其中提取出alpha通道并显示;</p><p>3）用alpha混合，为a.png替换一张新的背景（bg.png）。 </p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221027221157348.png" alt="image-20221027221157348"></p></blockquote><h3 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1-1"></a>实验1-1</h3><p>首先是实现从文件加载图像。</p><p>对于像以<code>jpg</code>, <code>png</code>, <code>bmp</code> 甚至<code>webp</code>为文件格式（后缀）的静态图片来说，打开并加载的方式又很多种，因为除了OpenCV以外，python还有很多图像处理的库。</p><p>对于此实验，可以使用 opencv或者python的PIL库（pillow）来实现。</p><h4 id="打开静态图片"><a href="#打开静态图片" class="headerlink" title="打开静态图片"></a>打开静态图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">path=<span class="string">&#x27;./1-1/eg.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#opencv</span></span><br><span class="line">img=cv2.imread(path,cv2.IMREAD_UNCHANGED)</span><br><span class="line"><span class="comment">#nameWindow()的作用是为图片准备一个窗口，使得图片是可交互的（如改变大小，这与第二个参数有关），前提是nameWindow和imshow的命名一致。</span></span><br><span class="line"><span class="comment">#直接使用imshow而不用nameWindow也行</span></span><br><span class="line">cv2.nameWindow(<span class="string">&#x27;girl&#x27;</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;girl&#x27;</span>,img)</span><br><span class="line"><span class="comment">#waitKey中参数决定了窗口打开时长，当参数为0时表示需要手动操作，不会自动关闭。</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#PIL</span></span><br><span class="line">img=Image.<span class="built_in">open</span>(path)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><h4 id="打开GIF图"><a href="#打开GIF图" class="headerlink" title="打开GIF图"></a>打开GIF图</h4><p>由于没有基础，做这个就颇费了一番功夫，好在也不算太复杂。</p><p>对此，我也找到了两种实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#识别图像模式</span></span><br><span class="line">im=Image.<span class="built_in">open</span>(file)</span><br><span class="line"><span class="comment">#gif图的mode为P，其他图像一般为RGB或者RGBA</span></span><br><span class="line"><span class="built_in">print</span>(im.mode)</span><br><span class="line"><span class="comment">#或者根据文件的格式来选择读入时使用的方法</span></span><br><span class="line"><span class="built_in">print</span>(im.<span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用PIL库来处理GIF</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showGif1</span>(<span class="params">im</span>):</span><br><span class="line">    <span class="comment">#使用迭代器</span></span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):    </span><br><span class="line">        frame = frame.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        cv2_frame = np.array(frame)</span><br><span class="line">        show_frame = cv2.cvtColor(cv2_frame, cv2.COLOR_RGB2BGR)</span><br><span class="line">        cv2.imshow(im.<span class="built_in">format</span>, show_frame)</span><br><span class="line">        cv2.waitKey(<span class="number">10</span>)   </span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用opencv的videoCaptrue来处理GIF</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showGif2</span>(<span class="params">file</span>):</span><br><span class="line">    cap = cv2.VideoCapture(file)</span><br><span class="line">    <span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">        <span class="comment"># 一帧一帧捕捉</span></span><br><span class="line">        <span class="comment"># ret=True if it finds a frame else False. </span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 对帧的操作,转为灰度图像</span></span><br><span class="line">        <span class="comment"># gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">        <span class="comment"># 显示返回的每帧</span></span><br><span class="line">        <span class="comment"># cv2.imshow(&#x27;frame&#x27;,gray)</span></span><br><span class="line">        <span class="comment"># 正常读</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;GIF&#x27;</span>,frame)</span><br><span class="line">        cv2.waitKey(<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 当所有事完成，释放 VideoCapture 对象</span></span><br><span class="line">    cap.release()</span><br><span class="line">    cv2.destroyAllWindows()    </span><br></pre></td></tr></table></figure><h4 id="图像同窗"><a href="#图像同窗" class="headerlink" title="图像同窗"></a>图像同窗</h4><p>此外，要实现图片中的效果，还需要将四张图片拼接在一起，确切地说是把他们放到同一个窗口中。又花了一天左右，终于实现了此功能，进度太慢了，主要还是不了解python和它的库……</p><h5 id="静态图片同窗"><a href="#静态图片同窗" class="headerlink" title="静态图片同窗"></a>静态图片同窗</h5><p>实现图像同窗展示，其一是用另一个库pyplot的功能。</p><p>关键代码就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 先用cv2读入文件</span></span><br><span class="line">img=cv2.imread(file)</span><br><span class="line"><span class="comment"># 再转换图片的模式，因为opencv处理图像是以BGR处理，python库是以RGB处理</span></span><br><span class="line"><span class="comment"># 若不转换模式，图片展示时颜色会异于原图</span></span><br><span class="line">img=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># 三个参数依次为目标窗口展示图片的行，列和读入图片所在位置</span></span><br><span class="line">plt.subplot(row,col,location)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"><span class="comment"># 图片上的标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;title.png&#x27;</span>)</span><br><span class="line"><span class="comment"># 用以隐藏附着于图的坐标系</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"><span class="comment"># 作用和上面一行代码一致，二者可替换</span></span><br><span class="line"><span class="comment"># plt.xticks([])</span></span><br><span class="line"><span class="comment"># plt.yticks([])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示拼接后的窗口</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>实现效果</strong></p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221028222036144.png" alt="image-20221028222036144"></p><p>但是上面方法实现的还不够，因为还需要将一张gif存进去。而我实现gif图的展示的最终方式都是通过逐帧播放。</p><p>如果使用python库，如pillow，它打开图片的方式是下面这样，窗口要手动关闭或者借助其他库来关闭，这就使得图片不能连续播放。而opencv的imshow则可以设置cv2.waitKey(time)自动刷新，进而控制gif的播放速度。为了使gif也能和其他静态图片同窗，需要找到其他方法，但是已经很接近了。</p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221028223134711.png" alt="image-20221028223134711"></p><h5 id="动静同窗"><a href="#动静同窗" class="headerlink" title="动静同窗"></a>动静同窗</h5><p>上课的时候，学到图片本质就是像素的堆叠。一般来说，图像是一个标准的举行，有着长宽。而矩阵也有行和列，矩阵的操作在数学和计算机中的处理都很常见且成熟，于是很自然的就把图像作为一个矩阵，把对图像的操作转换成对矩阵的操作，实际上所有的图像处理工具都是这么做的。所以接下来，我们操作的本质也是把图片当矩阵处理。</p><p>ps:这些其实都是做完实验后分析过程和结论给出的马后炮了，上课的时候我可没记住……</p><p>开始我找到的还是简单的将图片堆叠的方法，具体就是使用python的numpy库来。<strong>NumPy</strong>(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。图片像素值的读取，替换，随机剪裁，拼接等等都可以使用ndarray。对于已经习惯使用Numpy的人们来说，已经可以不使用OpenCV进行图像处理。</p><p>首先是<code>np.concatenate()</code>函数，它是用来对数列或矩阵进行合并的。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c=np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(c)   </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>此函数对数组的处理我并不是充分了解，但是先明白它是可以处理图像拼接的。</p><p><code>merge1=np.concatenate((img1,img2),axis=1)</code></p><p>此行代码的作用是实现两张的图片的横向拼接。不过在拼接前，要令被拼接的图像大小和格式一致，至少对横向拼接的两张图片而言，不要求都是正方形，但图片的纵向长度（宽）应该保持一致。</p><p><code>cv2.imshow(&#39;merge1&#39;,merge1)</code></p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-20221028230419526.png" alt="image-20221028230419526"></p><p>那剩下的一张静态图和一张gif，就可以继续横向拼接。但为了美观，我们可以将其拼接为<strong>“田”</strong>字。也就是在处理gif图时，插入<code>merge2=np.concatenate((img3,frame),1)</code>来拼接图三和gif的某一帧frame，然后再将两张横向图进行纵向的拼接，最后展示。</p><p>也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> # 纵向拼接两个图像</span><br><span class="line">merge=np.concatenate((merge1,merge2),0)</span><br><span class="line"># 展示</span><br><span class="line">cv2.imshow(&#x27;GIF&#x27;,merge)</span><br><span class="line">cv2.waitKey(10)</span><br></pre></td></tr></table></figure><p>最终结果</p><p><img src="/2022/10/27/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81OpenCV%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/res.gif" alt="res"></p><p>此外，还可以用 </p><p><code>merge1=np.hstack([img1,img2])</code></p><p><code>merge2=np.hstack([img3,frame])</code></p><p><code>merge=np.vstack([merge1,merge2])</code></p><p>分别替代上面的<code>np.concatenate()</code>函数，实现的效果是一样的。</p><p>那么至此，实验1-1算是做完了。</p><h4 id="保存gif"><a href="#保存gif" class="headerlink" title="保存gif"></a>保存gif</h4><p>但是写实验报告时，也许还需要贴一张gif图来展示，那么如何制作一张gif图片呢？</p><p>要制作gif图，首先要准备足够的图片作为gif或者视频的帧页，对此，我需要在前面的循环中保存每一帧图片。</p><p>在循环中插入代码</p><p><code>cv2.imwrite(&quot;./frames/frame%d.png&quot; % i,merge)</code></p><p>即可。</p><p>然后根据已有帧页，制作gif。</p><p>方法有很多，贴一个我使用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">frames = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">110</span>):</span><br><span class="line">    <span class="comment"># print(img)</span></span><br><span class="line">img = imageio.imread(<span class="string">&#x27;./frames/frame&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))  <span class="comment"># RGB格式的array</span></span><br><span class="line">frames.append(img)</span><br><span class="line">imageio.mimsave(<span class="string">&#x27;res.gif&#x27;</span>, frames, fps=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>注意不要使用这种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;data&#x27;</span></span><br><span class="line">files = [os.path.join(path, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path)]</span><br><span class="line">frames = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">img = imageio.imread(f)  <span class="comment"># RGB格式的array</span></span><br><span class="line">frames.append(img)</span><br><span class="line">imageio.mimsave(<span class="string">&#x27;res.gif&#x27;</span>, frames, fps=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>具体来说是指循环的方式。当帧数大于100时，此循环读文件的顺序并不是我们想象中的从file1到file101，而是按file1,  file100, file101, file102 ,…, file2, file3, … file99的顺序来读的，这使得合成的图片播放顺序有明显的错误。</p><p>这下才算真的而做完了1-1，下一篇更新实验1-2，图像合成。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 <a href="https://opencv.apachecn.org/#/docs/4.0.0/1.1-tutorial_py_intro">OpenCV-Python 教程简介 (apachecn.org)</a></p><p>2 <a href="http://c.biancheng.net/pillow/what-is-pillow.html">Pillow是什么 (biancheng.net)</a></p><p>3 <a href="https://blog.csdn.net/sumaliqinghua/article/details/90404173">Vscode的相对路径读取问题及处理</a></p><p>4 <a href="%5B%E3%80%90OpenCV%E3%80%91imshow()%E5%92%8CnamedWindow(">【OpenCV】imshow()和namedWindow()之间的关系</a>之间的关系，解决两个窗口问题_Running Y的博客-CSDN博客_namedwindow](<a href="https://blog.csdn.net/weixin_43243787/article/details/104755685">https://blog.csdn.net/weixin_43243787/article/details/104755685</a>))</p><p>5 <a href="https://blog.csdn.net/ITBigGod/article/details/87009082">python使用opencv或matplotlib把多张图片显示在一个窗口内</a></p><p>6 <a href="https://www.geeksforgeeks.org/how-to-display-multiple-images-in-one-window-using-opencv-python/">How to Display Multiple Images in One Window using OpenCV Python? - GeeksforGeeks</a></p><p>7 <a href="https://www.cnblogs.com/lfri/p/10596888.html">Python-OpenCV中图像合并显示 </a></p><p>8 <a href="https://blog.csdn.net/weixin_43360801/article/details/109487956">OpenCV实验（1）：图像的加载与显示_</a></p><p>9 <a href="https://www.cnblogs.com/xiaofeng91/p/14840128.html">pip安装第三方库报错</a></p><p>10 <a href="https://blog.csdn.net/weixin_43508499/article/details/115522755">opencv把一系列图像保存为视频、一系列图像保存为gif</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何上传本地的图片到一篇博客文章中？</title>
      <link href="/2022/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本地的md文件中插入了一些图片，上传到博客中，图片却没加载出来，控制台404错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load resource: the server responded with a status of 404 (Not Found)</span><br></pre></td></tr></table></figure><p>如何在在博客中插入图片？</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/imgs/blog学习/图片上传/bighead.jpg" width="40%" height="40%">    <br></center><span id="more"></span><h3 id="MarkDown-中图片插入"><a href="#MarkDown-中图片插入" class="headerlink" title="MarkDown 中图片插入"></a>MarkDown 中图片插入</h3><p><strong>首先，要说到markdown文件中图片的插入格式。</strong></p><p>一般，我在做笔记的时候，插入图片的方法是直接将图片通过拖拽的方式插入到md文件中，这样在md中就能直接看到插入的图片效果。</p><p>但和doc文件不一样，md文件并不是通过将整个图片插入到文章中来实现图片的展示的，而是通过在文章中插入图片的存放路径来找到资源、间接展示，可以想到，这样的方式和html文件中插入图片的方式是一致的（ 事实上，md也支持html语法）。这就解释了两个问题：</p><blockquote><p>1、为什么一篇文章中明明插入了很多张图片，实际大小确实只有几十kb？</p></blockquote><p>因为文件中只存放了图片路径，也就是只有文字，没有图片数据。</p><blockquote><p>2、为什么过一段时间，我的文章中的图片莫名其妙就裂开了？</p></blockquote><p>可能因为你写文章时用的图片是从某个地方随意摘取的，清理数据或者整理文件夹时，图片的存放位置改变或者被删除，但是文章中存放的路径没变，相当于刻舟求剑了。</p><ol><li></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/imgs/blog学习/图片上传/图片裂开.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">这是md文件中图片丢失的样子</div></center><ol start="2"><li></li></ol><p><img src="/imgs/blog%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/%E9%94%99%E8%AF%AF%E8%B7%AF%E5%BE%84.png" alt="错误路径"></p><center>  <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">这是web页面中图片丢失的样子</div></center><p>md中的图片插入的语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图像的替换文本](文件路径/图片名.png)</span><br></pre></td></tr></table></figure><p>一般来说，通过拖拽方式插入的图片，文件路径一般是图片的<strong>绝对路径</strong>，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图像的替换文本](D:\文件夹\图片名.png) </span><br></pre></td></tr></table></figure><p>还有一种，是通过<strong>相对路径</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图像的替换文本](..\图片文件夹\图片名.png) </span><br></pre></td></tr></table></figure><p>具体路径解析：</p><p>比如这篇文章的存放地址是 D: \项目文件夹\文章文件夹\文章.md</p><p>而文章中用到的图片的位置是D: \项目文件夹\图片文件夹\图片.jpg</p><p>那么使用相对路径时，就用” ..\ “来代表上一级文件夹，藏得越深，”..&quot;越多。</p><h3 id="typora图片相对路径设置"><a href="#typora图片相对路径设置" class="headerlink" title="typora图片相对路径设置"></a>typora图片相对路径设置</h3><p>首先一个问题，html中文件路径是左斜杠&#x2F;，md绝对路径用的是右斜杠\，这就导致如果想要在博客中展示图片，可能会使本地文件中看不到图片效果。</p><p>本人使用的解决方法为：在typora（编辑md文件使用的软件）中，设置图片根目录。设置的地方是格式→图像→设置图片根目录。然后把根目录设置为图片文件夹所在的地方，在文件中，图片的插入方式就是[图像的替换文本](&#x2F;文件路径&#x2F;图片名.png)，上传后，博客中图片也能正常显示了。</p><p><strong>注意，这种方法对每一个md文件都是独立的，而且与最后介绍的另一种方法冲突。</strong></p><p>eg. 下图路径：&#x2F;imgs&#x2F;blog学习&#x2F;图片上传&#x2F;设置路径.png</p><img src="/imgs/blog学习/图片上传/设置路径.png" alt="设置路径" style="zoom:50%;"><h3 id="博客中图片插入"><a href="#博客中图片插入" class="headerlink" title="博客中图片插入"></a>博客中图片插入</h3><p>再说回来，要想让同一路径下，md和网页的图片都正常显示，就还需要进行一些设置。</p><p>首先，对博客文件夹下的_config.yml做修改，将其中一个属性改为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true  //原为false</span><br></pre></td></tr></table></figure><p>然后安装一个插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>并在hexoblog\node_modules\hexo-asset-image 中将index.js文件内容替换为如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split(&#x27;.&#x27;);</span><br><span class="line">hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    var link = data.permalink;</span><br><span class="line">if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">   var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1;</span><br><span class="line">else</span><br><span class="line">   var beginPos = getPosition(link, &#x27;/&#x27;, 4) + 1;     //markdown的本地路径是xxx/x.jpg    hexo g编译后加上这句就是public/2020/05/26/xxx/xx.jpg 前4个文件+后一个图片~</span><br><span class="line">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="line">var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;];</span><br><span class="line">    for(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#x27;img&#x27;).each(function()&#123;</span><br><span class="line">if ($(this).attr(&#x27;src&#x27;))&#123;</span><br><span class="line">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br><span class="line">var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\&#x27;, &#x27;/&#x27;);</span><br><span class="line">if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">   !/^\s*\//.test(src)) &#123;</span><br><span class="line">  // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br><span class="line">  // In addition, to support multi-level local directory.</span><br><span class="line">  var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123;</span><br><span class="line">return elem != &#x27;&#x27;;</span><br><span class="line">  &#125;);</span><br><span class="line">  var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123;</span><br><span class="line">return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;;</span><br><span class="line">  &#125;);</span><br><span class="line">  if(srcArray.length &gt; 1)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(&#x27;/&#x27;);</span><br><span class="line">  $(this).attr(&#x27;src&#x27;, config.root + link + src);</span><br><span class="line">  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">console.info&amp;&amp;console.info($(this));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后博客中图片也可以正常显示了。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>但其实，上面的做法还是有点繁琐，比如图片文件与文章不在同一目录下，当文章数量变多时，插入图像就变成了比较麻烦的操作。</p><p>目标是，在文章同级文件夹下建立一个同名文件夹，使得md本地预览和网页都能正常显示。</p><p>折腾了一个下午和晚上，没找到理想方法，但下面这种算是接近。</p><p>要点：</p><ol><li><p>设置post_asset_folder: true  &#x2F;&#x2F;原为false</p></li><li><p>hexoblog\node_modules\hexo-asset-image 中将index.js文件内容替换代码</p></li><li><p>图片插入格式为![image](image.jpg) ，而非![image](文章名&#x2F;image.jpg) 。这样在博客中能正常展示，在md中虽然不能展示，但是加个文件名也能看到。此时不能设置文件根路径，否则本地也看不见。</p></li><li><p>对typora进行设置：文件→偏好设置→图像→复制到指定路径→.&#x2F;{$filename}，功能和上面一样，但是不在hexo中编辑时同样有用。</p></li><li><p>也可以是</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img  panda.jpg  image text %&#125;</span><br></pre></td></tr></table></figure></li><li><p>附加一个图片注解方式</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;img style=&quot;border-radius: 0.3125em;</span><br><span class="line">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; </span><br><span class="line">    src=&quot;地址&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    color: #999;</span><br><span class="line">    padding: 2px;&quot;&gt;注解&lt;/div&gt;</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要是图片大小控制的问题</p><p>有两种方式</p><ol><li>在asset_img外加div标签对，这个方法对md式![]()无效。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:40%;margin:auto;&quot;&gt;&#123;% asset_img bighead.jpg 图片信息描述 %&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用html的&lt;img&gt;标签，但是src中似乎只能填以source为根目录的额外建的imgs文件夹中的图片路径，直接使用图片名或者用文章同名文件夹中的图片都无效。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;img style=&quot;border-radius: 0.3125em;</span><br><span class="line">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; </span><br><span class="line">    src=&quot;/imgs/blog学习/图片上传/bighead.jpg&quot; width=&quot;40%&quot; height=&quot;40%&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>bighead.jpg</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/bighead.jpg" width="40%" height="40%"> <br></center></li><li><p>_posts\blog\博客以及md文件的图片上传\bighead.jpg </p><center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src=" \_posts\blog\博客以及md文件的图片上传\bighead.jpg " width="40%" height="40%"><br></center></li><li><p>&#x2F;_posts&#x2F;blog&#x2F;博客以及md文件的图片上传&#x2F;bighead.jpg</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/_posts/blog/博客以及md文件的图片上传/bighead.jpg" width="40%" height="40%"> <br></center></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、使用从source开始的相对路径+自己在source下建立一个img文件夹，在typora中设置图片根目录，加上上面几项设置。通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![代理图片名](/imgs/图片.png)</span><br></pre></td></tr></table></figure><p>能在文件和文章中看到同时看到图片。</p><p>2、设置文章同名文件夹，方便管理，上传网站时从图片路径中删去文件名，推荐使用。</p><p><img src="/2022/09/06/17/blog/%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Amd%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/blog%E5%AD%A6%E4%B9%A0/panda.jpg" alt="panda.jpg"></p><p>关于控制图片大小，以及插入的问题，还需要再看看。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/as3522/article/details/102972473">解决了hexo图像，但是md不显示</a></p><p><a href="https://blog.csdn.net/m0_43401436/article/details/107191688?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">同上，但分析较全</a></p>]]></content>
      
      
      <categories>
          
          <category> blog学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DBMS课设 --物业信息管理</title>
      <link href="/2022/09/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E8%AE%BE%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/09/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E8%AE%BE%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Property Information Management（prop_info）</p><p>作业时间2022.8.14-2022.9.1，大概17天</p><span id="more"></span><h2 id="DBMS课设-–物业信息管理"><a href="#DBMS课设-–物业信息管理" class="headerlink" title="DBMS课设 –物业信息管理"></a>DBMS课设 –物业信息管理</h2><p>Property Information Management（prop_info）</p><p>作业时间2022.8.14-2022.9.1，大概17天</p><p>主要信息管理: 业主信息、房屋信息</p><p>■费用收取： 物业费、水电煤气、有线电视、供暖、车位</p><p>■信息查询及报表:  月报表、季报表、年报表</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>前端：vue2, element.ui</p><p>后端：SpringBoot, MybatisPlus</p><p>数据库：Mysql</p><p>版本信息在具体模块查看</p><h2 id="系统功能分析"><a href="#系统功能分析" class="headerlink" title="系统功能分析"></a>系统功能分析</h2><p>定位为供物业工作人员使用的信息管理系统，功能分为四大模块</p><p><img src="/imgs/DBMS/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97.png" alt="功能模块"></p><p>具体功能通过用例图来展示</p><p><img src="/imgs/DBMS/%E7%94%A8%E4%BE%8B%E5%9B%BE.png" alt="用例图"></p><h3 id="部分功能分析"><a href="#部分功能分析" class="headerlink" title="部分功能分析"></a>部分功能分析</h3><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><p>初期：房屋、业主、车位设置（3000-10000）</p><p>稳定后：缴费（月增2000-4000）</p><h4 id="限购"><a href="#限购" class="headerlink" title="限购"></a>限购</h4><p>房屋、车位限购</p><p>房屋：业主&#x3D;1：n</p><p>房屋：车位&#x3D;1：1</p><h4 id="总账单"><a href="#总账单" class="headerlink" title="总账单"></a>总账单</h4><p>累加式(级联思想)</p><p>个人缴费———个人账单更新———物业总账单更新</p><h4 id="其他安全机制"><a href="#其他安全机制" class="headerlink" title="其他安全机制"></a>其他安全机制</h4><ul><li>绑定状态下不可更新或删除（房屋、车位、业主个人信息）。</li><li>房屋、车位、业主信息的冲突检查。</li><li>暂无房产业主不可缴费，不可购入或租入车位。</li><li>仅租车位业主应缴车位费。</li><li>共同业主共享缴费清单，避免重复缴费。</li></ul><h3 id="房屋管理"><a href="#房屋管理" class="headerlink" title="房屋管理"></a>房屋管理</h3><p>房屋信息</p><p><img src="/imgs/DBMS/%E6%88%BF%E5%B1%8B%E4%BF%A1%E6%81%AF.png" alt="房屋信息"></p><p>房屋-查看业主</p><p><img src="/imgs/DBMS/%E6%88%BF%E5%B1%8B-%E6%9F%A5%E7%9C%8B%E4%B8%9A%E4%B8%BB.png" alt="房屋-查看业主"></p><p>房屋编辑&amp;新增</p><p><img src="/imgs/DBMS/%E6%88%BF%E5%B1%8B%E7%BC%96%E8%BE%91&%E6%96%B0%E5%A2%9E.png" alt="房屋编辑&amp;新增"></p><h3 id="车位管理"><a href="#车位管理" class="headerlink" title="车位管理"></a>车位管理</h3><p>车位信息</p><p><img src="/imgs/DBMS/%E8%BD%A6%E4%BD%8D%E4%BF%A1%E6%81%AF.png" alt="车位信息"></p><p>车位-查看业主</p><p><img src="/imgs/DBMS/%E8%BD%A6%E4%BD%8D-%E6%9F%A5%E7%9C%8B%E4%BF%A1%E6%81%AF.png" alt="车位-查看信息"></p><p>车位-编辑&amp;新增</p><p><img src="/imgs/DBMS/%E8%BD%A6%E4%BD%8D%E7%BC%96%E8%BE%91&%E6%96%B0%E5%A2%9E.png" alt="车位编辑&amp;新增"></p><h3 id="业主管理"><a href="#业主管理" class="headerlink" title="业主管理"></a>业主管理</h3><p>业主信息</p><p><img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB%E4%BF%A1%E6%81%AF.png" alt="业主信息"></p><p>业主-房产车位</p><p><img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB-%E6%88%BF%E4%BA%A7%E8%BD%A6%E4%BD%8D.png" alt="业主-房产车位"></p><p>业主-缴费<img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB-%E7%BC%B4%E8%B4%B9.png" alt="业主-缴费"></p><p>业主-房产车位</p><p><img src="/imgs/DBMS/%E4%B8%9A%E4%B8%BB-%E6%88%BF%E4%BA%A7%E8%BD%A6%E4%BD%8D.png" alt="业主-房产车位"></p><h3 id="物业账单"><a href="#物业账单" class="headerlink" title="物业账单"></a>物业账单</h3><p>物业账单<img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E8%B4%A6%E5%8D%95.png" alt="物业账单"></p><p>物业账单-年与季筛选</p><p><img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E8%B4%A6%E5%8D%95-%E5%B9%B4%E4%B8%8E%E5%AD%A3%E7%AD%9B%E9%80%89.png" alt="物业账单-年与季筛选"></p><p>物业账单-月筛选<img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E8%B4%A6%E5%8D%95-%E6%9C%88%E7%AD%9B%E9%80%89.png" alt="物业账单-月筛选"></p><p>报表-折线</p><p><img src="/imgs/DBMS/%E6%8A%A5%E8%A1%A8-%E6%8A%98%E7%BA%BF.png" alt="报表-折线"></p><p>报表-饼</p><p><img src="/imgs/DBMS/echart-pie.png" alt="报表-饼"></p><h2 id="前端prop-vue"><a href="#前端prop-vue" class="headerlink" title="前端prop_vue"></a>前端prop_vue</h2><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>1、环境配置：</p><p>node  v16.13.1</p><p>npm   v8.14.0</p><p>vue     @vue&#x2F;cli 5.0.8</p><p>2、使用@vue&#x2F;cli脚手架构建一个vue2项目</p><p>地址：D:\code\DBMS\prop_info\prop_vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1）将vue项目建在D盘的目标文件夹下，cmd中进入该目录，输入新建项目命令 vue create 项目名，执行后会自动生成</span><br><span class="line">vue项目。</span><br><span class="line">2）运行vue项目</span><br><span class="line">3）浏览器访问项目</span><br><span class="line">项目运行成功后浏览器访问地址 http://localhost:8080</span><br><span class="line">4）查看生成的vue项目结构</span><br><span class="line"></span><br><span class="line">&gt; vue create prop_info(名字不能含有大写字母npm)</span><br><span class="line">&gt; npm run serve</span><br><span class="line"></span><br><span class="line">安装的cli插件：router, vuex, bable</span><br><span class="line"></span><br><span class="line">5）使用IntelliJ IDEA打开并运行该vue项目</span><br><span class="line">点击菜单栏“Add Configurations”设置运行命令npm</span><br><span class="line">点击“serve”旁边运行按钮</span><br></pre></td></tr></table></figure><ol start="3"><li>引入element.ui（在main.js中引入）</li></ol><p><a href="https://element-plus.gitee.io/zh-CN/guide/installation.html#%E4%BD%BF%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8">安装 | Element Plus (gitee.io)</a></p><p>element.ui只适配Vue2，支持Vue3的是Element.plus</p><ol start="4"><li><p>跨域设置</p><p> 前后端应该占用本地不同的端口，同一端口会冲突。</p><p> 通过这个文件，实现前后端的连接。</p><p> 位置在vue文件夹下，和package.json、src文件夹平级</p><p> 文件名 vue.config.js</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 跨域配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;                //记住，别写错了devServer//设置本地默认端口  选填</span><br><span class="line">        // port: 8081,</span><br><span class="line">        proxy: &#123;                 //设置代理，必须填</span><br><span class="line">            &#x27;/api&#x27;: &#123;              //设置拦截器  拦截器格式   斜杠+拦截器名字，名字可以自己定</span><br><span class="line">                target: &#x27;http://localhost:8081&#x27;,     //代理的目标地址</span><br><span class="line">                changeOrigin: true,              //是否设置同源，输入是的</span><br><span class="line">                pathRewrite: &#123;                   //路径重写</span><br><span class="line">                    &#x27;/api&#x27;: &#x27;&#x27;                     //选择忽略拦截器里面的单词</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个页面</p><p> 需要在router的index.js中添加路由，在导航中设置路径</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/house&#x27;,</span><br><span class="line">    name: &#x27;House&#x27;,</span><br><span class="line">    component: House</span><br><span class="line">&#125;</span><br><span class="line">      &lt;el-menu-item index=&quot;/house&quot; style=&quot;font-size: 20px &quot;&gt;&lt;i class=&quot;el-icon-s-home&quot;&gt;&lt;/i&gt; 房屋管理&lt;/el-menu-item&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>前端东西很多且复杂，讲不清楚。有时间还是自己学学，参考自己做的项目。</p><p>此次的数据库课设，让我基本能独立搭建好一个管理系统的前端页面，不过vue的很多属性我确实也不会用。但就我用到的东西而言，已经能自己找出bug并修复了。</p><p>组件很重要，但是不太熟练。</p><p>奥，比较重要的一点是学会使用已有的前端开源框架，比如若依，这样省了很多事。就算不用，参考一些功能设计和ui也会有很大帮助。虽然这个是我做完项目之后，跟人交流时才知道的。</p><p><a href="http://www.twom.top/">RuoYi 若依官方网站 </a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>如何在页头的content中自定义变量</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">开始用的tag</span><br><span class="line">&lt;el-page-header @back=&quot;back&quot; content=&quot;房屋&amp;业主绑定&quot; style=&quot;color: blue&quot;&gt;&lt;/el-page-header&gt;</span><br><span class="line">&lt;el-tag size=&quot;medium&quot;&gt;房屋编号:&#123;&#123; this.housenumber &#125;&#125;&lt;/el-tag&gt;</span><br><span class="line"></span><br><span class="line">后来</span><br><span class="line">&lt;el-page-header @back=&quot;back&quot; content=&#123;&#123;this.headercontent&#125;&#125; style=&quot;color: blue&quot;&gt;&lt;/el-page-header&gt;</span><br><span class="line"></span><br><span class="line">报错，提示</span><br><span class="line">修改content=&#123;&#123;this.headercontent&#125;&#125;</span><br><span class="line">为:content=this.headercontent</span><br></pre></td></tr></table></figure><blockquote><p>如何引入echarts？</p></blockquote><p><a href="https://blog.csdn.net/qq_43471802/article/details/109136061?utm_medium=distribute.pc_category.none-task-blog-hot-2.nonecase&depth_1-utm_source=distribute.pc_category.none-task-blog-hot-2.nonecase&request_id=">如何在Vue中使用Echarts可视化库_</a></p><h2 id="后端prop-serve"><a href="#后端prop-serve" class="headerlink" title="后端prop_serve"></a>后端prop_serve</h2><p>SpringBoot+MybatisPlus</p><p>版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot  2.7.2</span><br><span class="line">MybatisPlus 3.5.2</span><br><span class="line">jdk 1.8</span><br></pre></td></tr></table></figure><h3 id="项目搭建-1"><a href="#项目搭建-1" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>地址D:\code\DBMS\prop_info\prop_serve</p><p>(若使用idea操作，在大文件夹下D:\code\DBMS\prop_info创建一个子模块maven即可)</p><p>方式一：直接使用idea创建（似乎因为网络问题，我失败了几次）</p><ol><li><p><a href="https://www.cnblogs.com/ljsh/p/14279992.html">使用SpringBoot搭建Web项目</a></p></li><li><p>创建spring_boot项目时，出现Error message: Cannot download ‘<a href="https://start.spring.io‘/">https://start.spring.io‘</a>: Read timed out，即连不上网络访问<a href="https://start.spring.io，怀疑是家里移动网的问题，按[方法](https://blog.csdn.net/weixin_45721753/article/details/125933528)更换其为阿里云的地址即可https://start.aliyun.com">https://start.spring.io，怀疑是家里移动网的问题，按[方法](https://blog.csdn.net/weixin_45721753/article/details/125933528)更换其为阿里云的地址即可https://start.aliyun.com</a></p></li><li><p>添加依赖，位置pom.xml</p></li><li><p>springweb, Lombok, MyBatis plus</p></li></ol><p>  方式二：通过[官网](<a href="https://start.spring.io/">Spring Initializr</a>)来创建，类似vue</p><p>  （网络问题再现，移动网mmp，挂了梯子才行。</p><p>Could not connnect to server. Please check your network.</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><h4 id="项目细节初见"><a href="#项目细节初见" class="headerlink" title="项目细节初见"></a>项目细节初见</h4><p>初见</p><p>先准备好几个文件夹，用于放不同类型的java文件</p><p>如entity，存放项目的实体类；controller存放业务功能类；mapper存放mapper文件。</p><h5 id="entity类"><a href="#entity类" class="headerlink" title="entity类"></a>entity类</h5><p>entity类注解，以Owner类为例。了解更多搜索“Mybatis-Plus实体类注解”，如<a href="https://blog.csdn.net/qq_42758288/article/details/113888770">Mybatisplus常用注解_袁浩东的博客-CSDN博客_mybatisplus注解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Data//使用lombok插件，省略了getter和setter的书写</span><br><span class="line">@TableName(&quot;owner&quot;)//表名与数据库中的表对应一致</span><br><span class="line">public class Owner &#123;</span><br><span class="line">//主键的注解</span><br><span class="line">    @TableId(value=&quot;seleId&quot;,type = IdType.AUTO)</span><br><span class="line">    private Long seleId;//作为选择数据的标记</span><br><span class="line"></span><br><span class="line">//其他字段的注解，当二者不一致时必须要用，比如数据库中字段是id_num，注解就写@TableField(&quot;id_num&quot;)。一致时可以省略。</span><br><span class="line"> @TableField(&quot;idnum&quot;)</span><br><span class="line">    private String idnum;//身份证</span><br><span class="line">    private String name;//姓名</span><br><span class="line">    private int gender;//性别</span><br><span class="line">    private String phone;//联系方式</span><br><span class="line">    private String work;//工作单位</span><br><span class="line">    private int family;//家庭人数</span><br><span class="line">//    不要了</span><br><span class="line">//    @TableField(&quot;houseProp&quot;)</span><br><span class="line">//    private int houseProp;//名下房产数</span><br><span class="line">//    @TableField(&quot;parkProp&quot;)</span><br><span class="line">//    private int parkProp;//名下私有车位数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h5><p>格式如下，其中@Mapper注解要看情况，有两种方式。</p><p>一、每个mapper类前都加@Mapper注解；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件名  OwnerMapper.interface</span><br><span class="line">@Mapper</span><br><span class="line">public interface OwnerMapper extends BaseMapper&lt;Owner&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、在项目启动类xxxApplication.java 前写@MapperScan(“com.prop_serve.mapper”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication//启动类的必要注解</span><br><span class="line">@MapperScan(&quot;com.prop_serve.mapper&quot;)</span><br><span class="line">public class PropServeApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(PropServeApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实使用第二种的MapperScan是最省力的，因为如果不在这里写，每个mapper都要自己手动注释@Mapper。</p><p><strong>注意：二者都存在的话，就会产生重复注入警告</strong></p><h5 id="controller类"><a href="#controller类" class="headerlink" title="controller类"></a>controller类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController  //必要的注解</span><br><span class="line">@RequestMapping(&quot;/owner&quot;)//前端访问路径</span><br><span class="line">public class OwnerControl &#123;</span><br><span class="line">@Resource  //mapper引导，每用一个不同的mapper，就加一个注解。</span><br><span class="line">    OwnerMapper ownerMapper;</span><br><span class="line">    </span><br><span class="line">@RequestMapping(&quot;/owner&quot;)//进一步细分路径</span><br><span class="line">public void Test()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="common类"><a href="#common类" class="headerlink" title="common类"></a>common类</h5><p>存放其他的一些配置文件类，比如result.java（对返回结果进行包装）和MybatisPlusConfig.java  分页插件</p><h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p>在java&#x2F;resource 中新建文件 application.yml，用于设置端口和连接数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  数据库连接配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/prop_info?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false &amp;serverTimezone=Asia/Shanghai #注意时区设置</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  check-config-location: true    #</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml #mapper位置</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true #开启驼峰命名</span><br><span class="line">    type-aliases-package: com.prop_serve.entity #实体类位置</span><br></pre></td></tr></table></figure><h4 id="增加功能"><a href="#增加功能" class="headerlink" title="增加功能"></a>增加功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RequestBody 参数注解，对应的参数需要是一个实体类，通过mapper的insert方法插入数据</span><br><span class="line"></span><br><span class="line">//    增加业主</span><br><span class="line">    @PostMapping(&quot;/addOwner&quot;)</span><br><span class="line">    public Result&lt;?&gt; addOwner(@RequestBody Owner newOwner) &#123;</span><br><span class="line">        QueryWrapper&lt;Owner&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(&quot;idnum&quot;, newOwner.getIdnum());</span><br><span class="line"></span><br><span class="line">        owner = ownerMapper.selectOne(queryWrapper);</span><br><span class="line">        if (owner != null) &#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;重复的业主证件号!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ownerMapper.insert(newOwner);</span><br><span class="line">        System.out.println(&quot;新增业主&quot; + newOwner.getIdnum());</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="编辑功能"><a href="#编辑功能" class="headerlink" title="编辑功能"></a>编辑功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 通过mapper的updateById方法更新数据，前提是对象中含有主键。</span><br><span class="line"> 如果没有，就先通过参数的一些属性，尝试从数据库中找到符合特点的数据（selectOne, selectList,selectPage等），然后进行更新。</span><br><span class="line"> </span><br><span class="line"> @PutMapping(&quot;/editOwner&quot;)</span><br><span class="line">    public Result&lt;?&gt; editOwner(@RequestBody Owner owner) &#123;</span><br><span class="line">//        先看有没有绑定房屋，如果有就阻止</span><br><span class="line">        QueryWrapper&lt;HouseBinding&gt; q1=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q1.eq(&quot;idnum&quot;,owner.getIdnum());</span><br><span class="line">//        能在房屋绑定表中找到数据，就阻止</span><br><span class="line">        if (houseBindingMapper.selectOne(q1)!=null)&#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;请先解除当前业主的房屋绑定!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        如果把身份证改成了另一人的，要阻止</span><br><span class="line">//        先按seleId找到原来数据，再进行对比</span><br><span class="line">        QueryWrapper&lt;Owner&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(&quot;idnum&quot;, owner.getIdnum());</span><br><span class="line">        Owner h = ownerMapper.selectOne(queryWrapper);</span><br><span class="line">        //如果新证件已经被注册过 且注册者不是自己，就阻止</span><br><span class="line">        if (h != null&amp;&amp;h.getSeleId()!=owner.getSeleId()) &#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;重复的业主证件号!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ownerMapper.updateById(owner);</span><br><span class="line">        System.out.println(&quot;更新业主&quot; + owner.getIdnum());</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1.通过querry 找到对应数据，使用delete()方法：ownerMapper.delete(q2)，使用forEach遍历批量删除数据;</span><br><span class="line">2.传入的是个对象，直接用deleteById()，批量删除为deleteBatchIds()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    单个删除用户</span><br><span class="line">    @DeleteMapping(&quot;/deleteSingle/&#123;idnum&#125;&quot;)</span><br><span class="line">    public Result&lt;?&gt; deleteSingle(@PathVariable String idnum) &#123;</span><br><span class="line">        //        先看有没有绑定房屋，如果有就阻止</span><br><span class="line">        QueryWrapper&lt;HouseBinding&gt; q1=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q1.eq(&quot;idnum&quot;,idnum);</span><br><span class="line">//        能在房屋绑定表中找到数据，就阻止</span><br><span class="line">        if (houseBindingMapper.selectOne(q1)!=null)&#123;</span><br><span class="line">            return Result.error(&quot;-1&quot;, &quot;请先解除当前业主的房屋绑定!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;Owner&gt; q2=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q2.eq(&quot;idnum&quot;,idnum);</span><br><span class="line">        ownerMapper.delete(q2);</span><br><span class="line">        System.out.println(&quot;删除业主&quot; + idnum);</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //    批量删除业主</span><br><span class="line">    @PostMapping(&quot;/deleteBatch&quot;)</span><br><span class="line">    public Result&lt;?&gt; deleteBatch(@RequestBody List&lt;String&gt; idnum) &#123;</span><br><span class="line">        //  删除业主前，检查是否还存在绑定房屋，如果有，则不能删除</span><br><span class="line">        for (String s : idnum) &#123;</span><br><span class="line">            QueryWrapper&lt;HouseBinding&gt; q=new QueryWrapper&lt;&gt;();</span><br><span class="line">            q.eq(&quot;idnum&quot;,s);</span><br><span class="line">            HouseBinding h=houseBindingMapper.selectOne(q);</span><br><span class="line">            if (h!=null)&#123;</span><br><span class="line">                String s1=&quot;删除失败，请先解除业主&quot;+ owner.getIdnum()+&quot;的房屋绑定！&quot;;</span><br><span class="line">                return Result.error(&quot;-1&quot;,s1);</span><br><span class="line">            &#125;</span><br><span class="line">            QueryWrapper&lt;Owner&gt; q1=new QueryWrapper&lt;&gt;();</span><br><span class="line">            q1.eq(&quot;idnum&quot;,s);</span><br><span class="line">            ownerMapper.delete(q1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;批量删除业主&quot;);</span><br><span class="line">        return Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//    分页+获取用户表，支持按证件号查找个人</span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result&lt;?&gt; findPage(@RequestParam(defaultValue = &quot;1&quot;) Integer pageNum,</span><br><span class="line">                              @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize,</span><br><span class="line">                              @RequestParam(defaultValue = &quot;&quot;) String search) &#123;</span><br><span class="line">//        LambdaQueryWrapper&lt;Owner&gt; wrapper = Wrappers.&lt;Owner&gt;lambdaQuery().like(Owner::getIdnum, search);</span><br><span class="line">        //        查询数据不为空，从第一页开始展示</span><br><span class="line">        if (!search.isEmpty())&#123;</span><br><span class="line">            pageNum=1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;Owner&gt; q=new QueryWrapper&lt;&gt;();</span><br><span class="line">        q.like(&quot;idnum&quot;, search).or().like(&quot;name&quot;, search);</span><br><span class="line"></span><br><span class="line">        Page&lt;Owner&gt; page = ownerMapper.selectPage(new Page&lt;&gt;(pageNum, pageSize), q);</span><br><span class="line"></span><br><span class="line">        return Result.success(page);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>说不太清楚，看文件吧</p><p>此处是LIst转page的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分页函数</span><br><span class="line"> *</span><br><span class="line"> * @param currentPage 当前页数</span><br><span class="line"> * @param pageSize    每一页的数据条数</span><br><span class="line"> * @param list        要进行分页的数据列表</span><br><span class="line"> * @return 当前页要展示的数据</span><br><span class="line"> * @author pochettino</span><br><span class="line"> */</span><br><span class="line">private Page getPages(Integer currentPage, Integer pageSize, List list) &#123;</span><br><span class="line">    Page page = new Page();</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int size = list.size();</span><br><span class="line">    if (pageSize &gt; size) &#123;</span><br><span class="line">        pageSize = size;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pageSize != 0) &#123;</span><br><span class="line">        // 求出最大页数，防止currentPage越界</span><br><span class="line">        int maxPage = size % pageSize == 0 ? size / pageSize : size / pageSize + 1;</span><br><span class="line">        if (currentPage &gt; maxPage) &#123;</span><br><span class="line">            currentPage = maxPage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前页第一条数据的下标</span><br><span class="line">    int curIdx = currentPage &gt; 1 ? (currentPage - 1) * pageSize : 0;</span><br><span class="line"></span><br><span class="line">    List pageList = new ArrayList();</span><br><span class="line">    // 将当前页的数据放进pageList</span><br><span class="line">    for (int i = 0; i &lt; pageSize &amp;&amp; curIdx + i &lt; size; i++) &#123;</span><br><span class="line">        pageList.add(list.get(curIdx + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page.setCurrent(currentPage).setSize(pageSize).setTotal(list.size()).setRecords(pageList);</span><br><span class="line"></span><br><span class="line">    return page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><blockquote><p>项目一直卡在resolving dependencies of xxx, 或者说resolving Maven dependencies</p></blockquote><p>解决方式参考</p><p><a href="https://blog.csdn.net/sun_luming/article/details/95327506">IDEA新建项目卡在下载Resolving dependencies of xxx</a></p><blockquote><p>Cannot resolve symbol ‘SpringBootApplication</p></blockquote><p>很可能是因为没连数据库但是使用了mybatis-plus依赖的缘故，总之先注释掉m-p就行了。</p><p>其他情况，Maven设置中左上角刷新和install</p><p>以及</p><p><a href="https://blog.csdn.net/yexiaomodemo/article/details/119238320">IDEA “Cannot resolve symbol” 解决办法_悟能的师兄的博客-CSDN博客_cannot resolve symbol</a></p><blockquote><p>后端接口的验证方法</p></blockquote><p>学习使用apipost工具</p><blockquote><p> 批量删除功能无效</p></blockquote><p>后端参数RequestBody注解，但误用了DeleteMapping而不是RequestMapping</p><h2 id="数据库prop-info"><a href="#数据库prop-info" class="headerlink" title="数据库prop_info"></a>数据库prop_info</h2><p>Server version: 8.0.27 MySQL Community Server - GPL</p><p>使用方式：以管理员身份运行cmd窗口，输入net start mysql 或net stop mysql来启动mysql</p><p>mysql连接方式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL -uxxx -pyyy  #xxx和yyyy分别是用户名和密码</span><br></pre></td></tr></table></figure><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>ER图和表结构</strong></p><p>说明：表中设置seleId选择标记的作用是，实现对unique属性的编辑。比如说要修改一个人的证件号和其他身份信息，如果把证件号作为主键，后端实现修改功能时就会很复杂，而且这样的操作也是危险的，因为它是与其他信息有所关联的。</p><h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><p><img src="/imgs/DBMS/%E7%89%A9%E4%B8%9A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FER%E5%9B%BE%E5%85%A8%E5%B1%9E%E6%80%A7.png" alt="物业管理系统ER图全属性"></p><h4 id="业主表owner"><a href="#业主表owner" class="headerlink" title="业主表owner"></a>业主表owner</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增，非空</td><td>int(10) unsigned zerofill NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>name</td><td>非空</td><td>varchar(50) NOT NULL</td><td>业主姓名</td></tr><tr><td>gender</td><td>非空</td><td>int NOT NULL</td><td>业主性别</td></tr><tr><td>idnum</td><td>非空，unique</td><td>varchar(50) NOT NULL</td><td>证件号</td></tr><tr><td>phone</td><td>非空</td><td>varchar(50) NOT NULL</td><td>联系方式</td></tr><tr><td>work</td><td>非空</td><td>varchar(100) NOT NULL</td><td>工作单位</td></tr><tr><td>family</td><td>默认“1”</td><td>int NULL</td><td>家庭人数</td></tr></tbody></table><p>说明：表中设置seleId选择标记的作用是，实现对unique属性的编辑和校验。</p><p>比如说要修改一个人的证件号和其他身份信息，如果把证件号作为主键，后端实现修改功能时就会很复杂，而且这样的操作也是危险的，因为它是与其他信息有所关联的。</p><h4 id="房屋表house"><a href="#房屋表house" class="headerlink" title="房屋表house"></a>房屋表house</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增，非空</td><td>int NOT NULL</td><td>标记，作为选中数据的标记，自增</td></tr><tr><td>housenumber</td><td>unique，非空</td><td>varchar(10) NOT NULL</td><td>房屋编号，格式为_b_u_f_d</td></tr><tr><td>housetype</td><td>非空</td><td>varchar(10) NOT NULL</td><td>户型，格式为_r_h_t</td></tr><tr><td>area</td><td>非空，默认40（最小40）</td><td>float NOT NULL</td><td>面积,单位平米</td></tr><tr><td>hnum</td><td>默认0</td><td>int NULL</td><td>业主人数，默认为0</td></tr><tr><td>h_building</td><td></td><td>varchar(10) NULL</td><td>栋</td></tr><tr><td>h_unit</td><td></td><td>varchar(10) NULL</td><td>单元</td></tr><tr><td>h_floor</td><td></td><td>varchar(10) NULL</td><td>层</td></tr><tr><td>h_door</td><td></td><td>varchar(10) NULL</td><td>门牌（户）</td></tr><tr><td>parking</td><td>默认“无”</td><td>varchar(20) NULL</td><td>绑定车位</td></tr><tr><td>occupation</td><td>默认“0”</td><td>int NULL</td><td>车位状态</td></tr></tbody></table><h4 id="房产绑定表-housebinding"><a href="#房产绑定表-housebinding" class="headerlink" title="房产绑定表 housebinding"></a>房产绑定表 housebinding</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>idnum</td><td>主键，unique</td><td>varchar(50) NOT NULL</td><td>业主证件号，每个人限购一套房，所以主键为证件号更方便</td></tr><tr><td>housenumber</td><td></td><td>varchar(50) NOT NULL</td><td>房屋编号，同一套房可以有多个共同业主共享产权</td></tr></tbody></table><h4 id="车位表-parkinglot"><a href="#车位表-parkinglot" class="headerlink" title="车位表 parkinglot"></a>车位表 parkinglot</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增，非空</td><td>int NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>parking</td><td>unique，非空</td><td>varchar(20) NOT NULL</td><td>停车位编号</td></tr><tr><td>occupation</td><td>非空，默认“0”</td><td>int(1) unsigned zerofill NULL</td><td>转让情况， 0表可租或可售，1表已租，2表已售出</td></tr></tbody></table><h4 id="车位绑定parkbinding"><a href="#车位绑定parkbinding" class="headerlink" title="车位绑定parkbinding"></a>车位绑定parkbinding</h4><table><thead><tr><th>Field</th><th></th><th>约束Type</th><th>Comment</th></tr></thead><tbody><tr><td>parking</td><td>主键，unique，非空</td><td>varchar(20) NOT NULL</td><td>停车位</td></tr><tr><td>housenumber</td><td>非空</td><td>varchar(10) NOT NULL</td><td>房屋号，小区业主才能购买或者租入车位，一户最多一个</td></tr><tr><td>occupation</td><td>非空</td><td>int NOT NULL</td><td>所属情况（2表购入，1表租入）</td></tr></tbody></table><p>一房一车，但是绑定时输入的是业主的证件号，填入数据库的是查询到的绑定的房屋编号</p><h4 id="房屋缴费表perfee"><a href="#房屋缴费表perfee" class="headerlink" title="房屋缴费表perfee"></a>房屋缴费表perfee</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增</td><td>int NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>housenumber</td><td></td><td>varchar(10) NOT NULL</td><td>房屋编号</td></tr><tr><td>chargetime</td><td></td><td>date NULL</td><td>收款月份</td></tr><tr><td>expectfee</td><td>默认0</td><td>double NULL</td><td>预计总费</td></tr><tr><td>property</td><td>默认0</td><td>double NULL</td><td>物业费</td></tr><tr><td>water</td><td>默认0</td><td>double NULL</td><td>水</td></tr><tr><td>elec</td><td>默认0</td><td>double NULL</td><td>电</td></tr><tr><td>gas</td><td>默认0</td><td>double NULL</td><td>天然气</td></tr><tr><td>tv</td><td>默认0</td><td>double NULL</td><td>电视</td></tr><tr><td>heating</td><td>默认0</td><td>double NULL</td><td>暖气</td></tr><tr><td>park</td><td>默认0</td><td>double NULL</td><td>车位费（租）</td></tr></tbody></table><h4 id="物业总缴费表"><a href="#物业总缴费表" class="headerlink" title="物业总缴费表"></a>物业总缴费表</h4><table><thead><tr><th>Field</th><th>约束</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>seleId</td><td>主键，unique，自增</td><td>int NOT NULL</td><td>作为选中数据的标记</td></tr><tr><td>chargetime</td><td>unique</td><td>date NULL</td><td>收款月份，设为独特防止冲突</td></tr><tr><td>totalf</td><td>默认0</td><td>double NULL</td><td>预计总费</td></tr><tr><td>property</td><td>默认0</td><td>double NULL</td><td>物业费</td></tr><tr><td>water</td><td>默认0</td><td>double NULL</td><td>水</td></tr><tr><td>elec</td><td>默认0</td><td>double NULL</td><td>电</td></tr><tr><td>gas</td><td>默认0</td><td>double NULL</td><td>天然气</td></tr><tr><td>tv</td><td>默认0</td><td>double NULL</td><td>电视</td></tr><tr><td>heating</td><td>默认0</td><td>double NULL</td><td>暖气</td></tr><tr><td>park</td><td>默认0</td><td>double NULL</td><td>车位</td></tr></tbody></table><h3 id="模拟数据批量生成"><a href="#模拟数据批量生成" class="headerlink" title="模拟数据批量生成"></a>模拟数据批量生成</h3><p>一、使用网站或其他工具</p><p><a href="https://www.toolscat.com/dev/data-generator">批量生成模拟数据在线工具—工具猫 (toolscat.com)</a></p><p>二、结合网站工具和excel、txt模拟复杂格式的数据</p><p><a href="https://blog.csdn.net/qq_27468351/article/details/79728233">使用Excel批量生成sql,包括日期格式_我的屎壳郎君的博客-CSDN博客</a></p><p>如时间，特殊格式的字符串，求和，字符串合并</p><p>excel很强大，数据可以按格式自动赋值传递。</p><p>时间类的字段直接用是数字类型的，如果想保留为字符串，就先复制到txt文件中，再设置目标行的段落格式为文本类型，然后粘贴即可。</p><p>总之，模拟好数据后，总要转化成sql脚本。</p><p>方法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=CONCATENATE(&quot;insert ignore into TableName (属性1,属性2,属性3) value (&#x27;&quot;&amp;B2&amp;&quot;&#x27;,&quot;&amp;C2&amp;&quot;,&quot;&amp;D2&amp;&quot;);&quot;)</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">1、 =CONCATENATE(&quot;sql-script&quot;) sql-script指的是sql脚本</span><br><span class="line">2、 insert ignore into TableName的ignore指的是忽略插入错误的行，执行所有没有问题的数据，这在批量执行时有用。</span><br><span class="line">3、 &quot;&amp;C2&amp;&quot; 双引号中包裹的是excel表格中目标数据位置，如果是字符串，还要套上一层单引号&#x27;&quot;&amp;B2&amp;&quot;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World！</title>
      <link href="/2022/07/20/22/%E6%9D%82%E8%B0%88/test/%E6%9D%82%E8%B0%88/"/>
      <url>/2022/07/20/22/%E6%9D%82%E8%B0%88/test/%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>测试</p><span id="more"></span><p>在终于换好了主题，博客也基本搭好了。大概在21年暑假就准备做的博客，因为各种包和主题的问题屡屡失败，最终不了了之。</p><p>这次折腾了大半天。本来想用claudia主题，但是似乎某些必要的包过时了，主题用不了，先用着Next主题吧。</p><p>此后博客的内容就是对本人的学习和项目的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
